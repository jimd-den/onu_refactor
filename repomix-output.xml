This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where comments have been removed, empty lines have been removed, line numbers have been added.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: **/node_modules/**, **/dist/**, scripts
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Empty lines have been removed from all files
- Line numbers have been added to the beginning of each line
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
samples/
  ackermann.onu
  bf.onu
  collatz_bench.onu
  collatz.onu
  echo_demo.onu
  factorial.onu
  fibonacci.onu
  guess.onu
  hanoi.onu
  hello_world_int.onu
  hello_world.onu
  illegal_shared.onu
  map_bench.onu
  mutation.onu
  parity.onu
  sample.onu
  svo_e2e.onu
  tui_demo.onu
src/
  adapters/
    codegen/
      mod.rs
      strategies.rs
    lexer/
      mod.rs
    parser/
      mod.rs
    mod.rs
  application/
    ports/
      compiler_ports.rs
      environment.rs
      mod.rs
    use_cases/
      analysis_service.rs
      layout_service.rs
      lowering_service.rs
      mir_builder.rs
      mir_lowering_service.rs
      mod.rs
      module_service.rs
      registry_service.rs
    mod.rs
    options.rs
  domain/
    entities/
      ast.rs
      core_module.rs
      error.rs
      hir.rs
      mir.rs
      mod.rs
      registry.rs
      types.rs
    rules/
      dry_enforcement.rs
      liveness.rs
      mod.rs
      ownership.rs
    mod.rs
  infrastructure/
    cli/
      mod.rs
      parser.rs
    extensions/
      io.rs
      mod.rs
    os/
      mod.rs
    mod.rs
  lib.rs
  main.rs
tests/
  module_test.rs
  pipeline_test.rs
  samples_test.rs
.gitignore
Cargo.toml
collatz_bin
collatz.ll
factorial.ll
fibonacci.ll
hello_world_bin
hello_world.ll
onu_prog
output.bc
output.ll
parity.ll
runtime.c
sample_bin
sample.ll
test.onu
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="samples/ackermann.onu">
 1: -- ═══════════════════════════════════════════════════════════════════════════
 2: -- Discourse Unit: The Ackermann Growth Spiral
 3: -- Concern: Exploring the boundaries of recursive logic.
 4: --
 5: -- The Ackermann function is a "non-primitive recursive" sequence. 
 6: -- It grows faster than any standard mathematical notation (like exponents).
 7: -- It is defined by three active rules:
 8: -- 1. The Successor: When depth is zero, just add one.
 9: -- 2. The Descent: When intensity is zero, drop one depth and reset intensity.
10: -- 3. The Spiral: When both exist, solve for a smaller intensity, then 
11: --                use that result to solve for a smaller depth.
12: -- ═══════════════════════════════════════════════════════════════════════════
13: 
14: the module called RecursiveGrowth
15:     with concern: exploring extreme mathematical sequences
16: 
17: -- Rule 1: The Successor
18: -- This is the "Base Case." When the growth tier reaches zero, we simply 
19: -- deliver the next number in the sequence.
20: the behavior called successor-of
21:     with intent: increment a value to find its next neighbor
22:     takes:
23:         an integer called value
24:     delivers: an integer
25:     as:
26:         value added-to 1
27: 
28: -- Rule 2: Tier Descent
29: -- When intensity is exhausted (zero), we descend to a lower tier of 
30: -- recursive growth and reset our intensity to the starting value of 1.
31: the behavior called descend-tier
32:     with intent: move to a lower recursive depth with a base intensity
33:     takes:
34:         an integer called depth
35:     delivers: an integer
36:     with no guaranteed termination
37:     as:
38:         derivation: lower-depth derives-from an integer depth decreased-by 1
39:         lower-depth utilizes ackermann 1
40: 
41: -- Rule 3: The Spiral
42: -- This is the heart of the growth. We calculate the result for a 
43: -- smaller intensity first, then feed that entire result back into 
44: -- a lower tier of recursive depth.
45: the behavior called spiral-down
46:     with intent: execute the nested recursive spiral
47:     takes:
48:         an integer called depth
49:         an integer called intensity
50:     delivers: an integer
51:     with no guaranteed termination
52:     as:
53:         derivation: lower-depth derives-from an integer depth decreased-by 1
54:         derivation: lower-intensity derives-from an integer intensity decreased-by 1
55:         
56:         -- First, find the "Inner Result" at the current depth
57:         derivation: inner-result derives-from depth utilizes ackermann lower-intensity
58:         
59:         -- Then, use that result to descend to the lower depth
60:         lower-depth utilizes ackermann inner-result
61: 
62: -- The Orchestrator
63: -- The Ackermann function coordinates our three rules based on current state.
64: the behavior called ackermann
65:     with intent: compute a value within the extreme growth spiral
66:     takes:
67:         an integer called depth
68:         an integer called intensity
69:     delivers: an integer
70:     with no guaranteed termination
71:     as:
72:         if depth matches 0
73:             then intensity utilizes successor-of
74:             else if intensity matches 0
75:                 then depth utilizes descend-tier
76:                 else depth utilizes spiral-down intensity
77: 
78: the effect behavior called run
79:     with intent: demonstrate the explosive nature of the Ackermann function
80:     takes: nothing
81:     delivers: nothing
82:     as:
83:         derivation: d1   derives-from nothing broadcasts "═══════════════════════════════════════════"
84:         derivation: d2   derives-from nothing broadcasts "  ACKERMANN GROWTH DEMONSTRATION"
85:         derivation: d3   derives-from nothing broadcasts "  Rules: Successor, Descent, and Spiral"
86:         derivation: d4   derives-from nothing broadcasts "═══════════════════════════════════════════"
87: 
88:         derivation: msg1 derives-from nothing broadcasts "Solving Spiral(2, 2)..."
89:         derivation: res1 derives-from an integer 2 utilizes ackermann 2
90:         derivation: out1 derives-from nothing broadcasts (res1 utilizes as-text)
91: 
92:         derivation: msg2 derives-from nothing broadcasts "Solving Spiral(3, 2)..."
93:         derivation: res2 derives-from an integer 3 utilizes ackermann 2
94:         derivation: out2 derives-from nothing broadcasts (res2 utilizes as-text)
95:         
96:         derivation: d5   derives-from nothing broadcasts "═══════════════════════════════════════════"
97:         nothing
</file>

<file path="samples/bf.onu">
  1: -- ═══════════════════════════════════════════════════════════════════════════
  2: -- Discourse Unit: The Esoteric Tape Machine (Brainfuck)
  3: -- Concern: Simulating a minimalist Turing machine.
  4: -- ═══════════════════════════════════════════════════════════════════════════
  5: 
  6: the module called TapeMachine
  7:     with concern: esoteric language emulation
  8: 
  9: -- Extract the current intensity from the tape at the given position.
 10: the behavior called read-tape
 11:     with intent: get the value at the current focus
 12:     takes:
 13:         a string called tape via observation
 14:         an integer called focus
 15:     delivers: an integer
 16:     as:
 17:         tape char-at focus
 18: 
 19: -- Update the intensity at the given position on the tape.
 20: the behavior called write-tape
 21:     with intent: set a new value at the current focus
 22:     takes:
 23:         a string called tape
 24:         an integer called focus
 25:         an integer called value
 26:     delivers: a string
 27:     as:
 28:         tape utilizes set-char focus value
 29: 
 30: -- Rule: Forward Jump Gate
 31: the behavior called navigate-forward-to-exit
 32:     with intent: find the matching closing bracket
 33:     takes:
 34:         a string called code via observation
 35:         an integer called instruction-pointer
 36:         an integer called depth-counter
 37:     delivers: an integer
 38:     with no guaranteed termination
 39:     as:
 40:         derivation: current-instr derives-from an integer code char-at instruction-pointer
 41:         derivation: next-ip derives-from an integer instruction-pointer added-to 1
 42:         
 43:         if current-instr matches 91 -- '['
 44:             then code utilizes navigate-forward-to-exit next-ip (depth-counter added-to 1)
 45:             else 
 46:                 if current-instr matches 93 -- ']'
 47:                     then
 48:                         if depth-counter matches 0
 49:                             then instruction-pointer
 50:                             else code utilizes navigate-forward-to-exit next-ip (depth-counter decreased-by 1)
 51:                     else code utilizes navigate-forward-to-exit next-ip depth-counter
 52: 
 53: -- Rule: Backward Jump Gate
 54: the behavior called navigate-backward-to-entrance
 55:     with intent: find the matching opening bracket
 56:     takes:
 57:         a string called code via observation
 58:         an integer called instruction-pointer
 59:         an integer called depth-counter
 60:     delivers: an integer
 61:     with no guaranteed termination
 62:     as:
 63:         derivation: current-instr derives-from an integer code char-at instruction-pointer
 64:         derivation: prev-ip derives-from an integer instruction-pointer decreased-by 1
 65:         
 66:         if current-instr matches 93 -- ']'
 67:             then code utilizes navigate-backward-to-entrance prev-ip (depth-counter added-to 1)
 68:             else
 69:                 if current-instr matches 91 -- '['
 70:                     then
 71:                         if depth-counter matches 0
 72:                             then instruction-pointer
 73:                             else code utilizes navigate-backward-to-entrance prev-ip (depth-counter decreased-by 1)
 74:                     else code utilizes navigate-backward-to-entrance prev-ip depth-counter
 75: 
 76: -- The Execution Engine
 77: the effect behavior called interpret
 78:     with intent: execute the sequence of tape instructions
 79:     takes:
 80:         a string called code via observation
 81:         an integer called ip
 82:         a string called tape
 83:         an integer called focus
 84:     delivers: nothing
 85:     with no guaranteed termination
 86:     as:
 87:         if ip falls-short-of (code utilizes len)
 88:             then
 89:                 derivation: instr derives-from an integer code char-at ip
 90:                 derivation: next-ip derives-from an integer ip added-to 1
 91:                 
 92:                 if instr matches 43 -- '+' (Oscillate Up)
 93:                     then
 94:                         derivation: val derives-from an integer tape utilizes read-tape focus
 95:                         derivation: new-tape derives-from a string tape utilizes write-tape focus (val added-to 1)
 96:                         code utilizes interpret next-ip new-tape focus
 97:                     else
 98:                 if instr matches 45 -- '-' (Oscillate Down)
 99:                     then
100:                         derivation: val derives-from an integer tape utilizes read-tape focus
101:                         derivation: new-tape derives-from a string tape utilizes write-tape focus (val decreased-by 1)
102:                         code utilizes interpret next-ip new-tape focus
103:                     else
104:                 if instr matches 62 -- '>' (Shift Focus Right)
105:                     then code utilizes interpret next-ip tape (focus added-to 1)
106:                     else
107:                 if instr matches 60 -- '<' (Shift Focus Left)
108:                     then code utilizes interpret next-ip tape (focus decreased-by 1)
109:                     else
110:                 if instr matches 46 -- '.' (Broadcast State)
111:                     then
112:                         derivation: val derives-from an integer tape utilizes read-tape focus
113:                         derivation: dummy derives-from nothing broadcasts (val utilizes char-from-code)
114:                         code utilizes interpret next-ip tape focus
115:                     else
116:                 if instr matches 91 -- '[' (Enter Gate)
117:                     then
118:                         derivation: val derives-from an integer tape utilizes read-tape focus
119:                         if val matches 0
120:                             then
121:                                 derivation: target derives-from an integer code utilizes navigate-forward-to-exit next-ip 0
122:                                 code utilizes interpret (target added-to 1) tape focus
123:                             else code utilizes interpret next-ip tape focus
124:                     else
125:                 if instr matches 93 -- ']' (Exit Gate)
126:                     then
127:                         derivation: val derives-from an integer tape utilizes read-tape focus
128:                         if val matches 0
129:                             then code utilizes interpret next-ip tape focus
130:                             else
131:                                 derivation: target derives-from an integer code utilizes navigate-backward-to-entrance (ip decreased-by 1) 0
132:                                 code utilizes interpret (target added-to 1) tape focus
133:                     else
134:                         code utilizes interpret next-ip tape focus
135:             else nothing
136: 
137: the effect behavior called run
138:     with intent: demonstrate the esoteric tape machine
139:     takes: nothing
140:     delivers: nothing
141:     as:
142:         derivation: empty-tape derives-from a string "          " 
143:         derivation: program    derives-from a string "++>+++<[->+<]>." -- Result: 2 + 3 = 5 (char code 5)
144:         derivation: d1         derives-from nothing broadcasts "Initializing Tape Machine..."
145:         program utilizes interpret 0 empty-tape 0
146:         nothing
</file>

<file path="samples/collatz_bench.onu">
 1: the module called CollatzBenchmark
 2:     with concern: recursive performance verification
 3: 
 4: the behavior called collatz-steps
 5:     with intent: count steps to reach 1
 6:     takes:
 7:         an integer called n
 8:         an integer called count
 9:     delivers: an integer
10:     with no guaranteed termination
11:     as:
12:         if n matches 1
13:             then count
14:             else
15:                 derivation: half    derives-from n partitions-by 2
16:                 derivation: is-even derives-from (half scales-by 2) matches n
17:                 derivation: next    derives-from if is-even then half else (n scales-by 3 added-to 1)
18:                 next utilizes collatz-steps (count added-to 1)
19: 
20: the behavior called collatz-range
21:     with intent: sum steps for a range of numbers
22:     takes:
23:         an integer called current
24:         an integer called target
25:         an integer called accumulator
26:     delivers: an integer
27:     with no guaranteed termination
28:     as:
29:         if current exceeds target
30:             then accumulator
31:             else
32:                 derivation: steps derives-from current utilizes collatz-steps 0
33:                 (current added-to 1) utilizes collatz-range target (accumulator added-to steps)
34: 
35: the effect behavior called run
36:     takes: nothing
37:     delivers: nothing
38:     as:
39:         derivation: limit  derives-from 1000000
40:         derivation: result derives-from 1 utilizes collatz-range limit 0
41:         
42:         derivation: msg derives-from "Total Collatz steps for 1 to " joined-with (limit utilizes as-text)
43:         derivation: msg2 derives-from msg joined-with " is: "
44:         derivation: d1 derives-from nothing broadcasts msg2
45:         broadcasts (result utilizes as-text)
46:         nothing
</file>

<file path="samples/collatz.onu">
 1: -- ═══════════════════════════════════════════════════════════════════════════
 2: -- Discourse Unit: Collatz Sequence Generation
 3: -- Concern: Visualizing the hailstone path.
 4: -- ═══════════════════════════════════════════════════════════════════════════
 5: 
 6: the module called CollatzVisualizer
 7:     with concern: sequence generation
 8: 
 9: -- Generate and broadcast terms
10: the effect behavior called broadcast-sequence
11:     with intent: deliver the first ten terms of the sequence
12:     takes:
13:         an integer called n
14:         an integer called terms-remaining
15:     delivers: nothing
16:     with no guaranteed termination
17:     as:
18:         derivation: d1 derives-from nothing broadcasts (n utilizes as-text)
19:         
20:         if n matches 1
21:             then nothing
22:             else
23:                 if terms-remaining matches 1
24:                     then nothing
25:                     else
26:                         derivation: half    derives-from n partitions-by 2
27:                         derivation: is-even derives-from (half scales-by 2) matches n
28:                         derivation: next    derives-from if is-even then half else (n scales-by 3 added-to 1)
29:                         
30:                         next utilizes broadcast-sequence (terms-remaining decreased-by 1)
31: 
32: the effect behavior called run
33:     with intent: demonstrate the first ten terms starting from 1000000
34:     takes: nothing
35:     delivers: nothing
36:     as:
37:         derivation: d1 derives-from nothing broadcasts "COLLATZ SEQUENCE (Starting at 1,000,000):"
38:         1000000 utilizes broadcast-sequence 10
39:         nothing
</file>

<file path="samples/echo_demo.onu">
 1: the module called EchoModule
 2:     with concern: testing CLI argument reception
 3: 
 4: the effect behavior called run
 5:     with intent: echo the first argument provided
 6:     takes: nothing
 7:     delivers: nothing
 8:     as:
 9:         derivation: count derives-from argument-count
10:         
11:         if count exceeds 0
12:             then
13:                 derivation: arg derives-from 0 utilizes receives-argument
14:                 broadcasts arg
15:             else
16:                 broadcasts "No arguments provided."
17:         
18:         nothing
</file>

<file path="samples/factorial.onu">
 1: -- ═══════════════════════════════════════════════════════════════════════════
 2: -- Discourse Unit: The Accumulation of History (Factorial)
 3: -- Concern: Calculating the product of a descending sequence.
 4: --
 5: -- The factorial of a number is the product of itself and every number 
 6: -- that came before it, down to the original seed.
 7: -- 1. The Seed: The sequence terminates at 0, which delivers a value of 1.
 8: -- 2. The Product: For any other number, we derive its predecessor and 
 9: --                 deliver the product of current and previous values.
10: -- ═══════════════════════════════════════════════════════════════════════════
11: 
12: the module called ArithmeticHistory
13:     with concern: sequential multiplication
14: 
15: -- Rule 1: The Seed
16: the behavior called terminal-seed
17:     with intent: deliver the base value for the sequence
18:     takes: nothing
19:     delivers: an integer
20:     as: 1
21: 
22: -- Rule 2: Sequential Product
23: the behavior called calculate-accumulation
24:     with intent: determine the product of a descending sequence
25:     takes:
26:         an integer called current-value
27:     delivers: an integer
28:     with diminishing: current-value
29:     as:
30:         if current-value matches 0
31:             then terminal-seed
32:             else
33:                 derivation: previous-value derives-from an integer current-value decreased-by 1
34:                 derivation: historical-sum  derives-from previous-value utilizes calculate-accumulation
35:                 current-value scales-by historical-sum
36: 
37: the effect behavior called run
38:     with intent: demonstrate the accumulation of history
39:     takes: nothing
40:     delivers: nothing
41:     as:
42:         derivation: target derives-from an integer 5
43:         derivation: result derives-from target utilizes calculate-accumulation
44:         
45:         derivation: msg derives-from a string "The accumulation of 5 steps is: "
46:         derivation: d1  derives-from nothing broadcasts msg
47:         derivation: d2  derives-from nothing broadcasts (result utilizes as-text)
48:         nothing
</file>

<file path="samples/fibonacci.onu">
 1: -- ═══════════════════════════════════════════════════════════════════════════
 2: -- Discourse Unit: The Sequence of Natural Growth
 3: -- Concern: Modeling how populations expand through time.
 4: --
 5: -- The Fibonacci sequence describes a pattern where every new generation 
 6: -- is the sum of the two generations that came before it.
 7: -- 1. The Origin: Generation 0 begins with nothing (0).
 8: -- 2. The Spark: Generation 1 introduces the first unit (1).
 9: -- 3. The Summation: Every subsequent generation combines its parent 
10: --                   and its grandparent to determine its size.
11: -- ═══════════════════════════════════════════════════════════════════════════
12: 
13: the module called GrowthModeling
14:     with concern: biological and mathematical expansion
15: 
16: -- Rule 1: The Origin
17: the behavior called origin-size
18:     with intent: deliver the starting value of the sequence
19:     takes: nothing
20:     delivers: an integer
21:     as: 0
22: 
23: -- Rule 2: The Spark
24: the behavior called spark-size
25:     with intent: deliver the initial growth value
26:     takes: nothing
27:     delivers: an integer
28:     as: 1
29: 
30: -- Rule 3: Generation Summation
31: -- This behavior coordinates the recursive lookback into history.
32: the behavior called calculate-growth
33:     with intent: determine the size of a specific generation
34:     takes:
35:         an integer called generation
36:     delivers: an integer
37:     with diminishing: generation
38:     as:
39:         if generation matches 0
40:             then origin-size
41:             else if (generation decreased-by 1) matches 0
42:                 then spark-size
43:                 else
44:                     derivation: parent      derives-from an integer generation decreased-by 1
45:                     derivation: grandparent derives-from an integer generation decreased-by 2
46:                     
47:                     derivation: p-size derives-from parent      utilizes calculate-growth
48:                     derivation: g-size derives-from grandparent utilizes calculate-growth
49:                     
50:                     p-size added-to g-size
51: 
52: the effect behavior called run
53:     with intent: demonstrate the sequence of growth
54:     takes: nothing
55:     delivers: nothing
56:     as:
57:         derivation: target derives-from an integer 40
58:         derivation: result derives-from target utilizes calculate-growth
59:         
60:         derivation: msg derives-from a string "The population at generation " joined-with (target utilizes as-text)
61:         derivation: msg2 derives-from a string msg joined-with " has reached: "
62:         derivation: d1   derives-from nothing broadcasts msg2
63:         broadcasts (result utilizes as-text)
64:         nothing
</file>

<file path="samples/guess.onu">
 1: the module called GuessingGame
 2:     with concern: interactive user engagement
 3: 
 4: the effect behavior called game-loop
 5:     with intent: prompt the user for guesses until they find the target
 6:     takes:
 7:         an integer called target
 8:         an integer called attempts
 9:     delivers: nothing
10:     with no guaranteed termination
11:     as:
12:         broadcasts "Enter your guess: "
13:         
14:         derivation: input derives-from receives-line
15:         derivation: guess derives-from input utilizes as-integer
16:         
17:         if guess matches target
18:             then
19:                 derivation: msg  derives-from "SUCCESS! You found the number in "
20:                 derivation: msg2 derives-from msg joined-with (attempts utilizes as-text)
21:                 derivation: msg3 derives-from msg2 joined-with " attempts!"
22:                 broadcasts msg3
23:             else
24:                 if guess exceeds target
25:                     then broadcasts "Lower..."
26:                     else broadcasts "Higher..."
27:                 
28:                 target utilizes game-loop (attempts added-to 1)
29: 
30: the effect behavior called run
31:     with intent: initialize the game with a random target
32:     takes: nothing
33:     delivers: nothing
34:     as:
35:         broadcasts "═══════════════════════════════════════════"
36:         broadcasts "       THE Ọ̀NỤ GUESSING GAME"
37:         broadcasts "═══════════════════════════════════════════"
38:         broadcasts "I have chosen a number between 1 and 100."
39:         
40:         -- Get entropy and map to 1-100
41:         derivation: raw derives-from receives-entropy
42:         derivation: target derives-from (raw partitions-by 100)
43:         derivation: actual derives-from raw decreased-by (target scales-by 100)
44:         derivation: final  derives-from (actual added-to 1)
45:         
46:         final utilizes game-loop 1
47:         nothing
</file>

<file path="samples/hanoi.onu">
  1: -- ═══════════════════════════════════════════════════════════════════════════
  2: -- Discourse Unit: The Grand Relocation (Towers of Hanoi)
  3: -- Concern: Orchestrating recursive inventory movement with total transparency.
  4: -- ═══════════════════════════════════════════════════════════════════════════
  5: 
  6: the module called LogisticsOrchestration
  7:     with concern: coordinated movement of hierarchical assets
  8: 
  9: -- Render the current state of a depot for the auditors.
 10: the effect behavior called inspect-depot
 11:     with intent: display the disks currently residing at a location
 12:     takes:
 13:         a string called depot-name via observation
 14:         a string called items      via observation
 15:     delivers: nothing
 16:     as:
 17:         derivation: header   derives-from a string depot-name joined-with ": ["
 18:         derivation: footer   derives-from a string header joined-with items
 19:         derivation: report   derives-from a string footer joined-with "]"
 20:         broadcasts report
 21:         nothing
 22: 
 23: -- Identify the item currently at the top of the stack.
 24: the behavior called identify-top-item
 25:     with intent: extract the disk at the peak of the tower
 26:     takes:
 27:         a string called stack via observation
 28:     delivers: a string
 29:     as:
 30:         derivation: count derives-from an integer stack utilizes len
 31:         if count matches 0
 32:             then ""
 33:             else
 34:                 derivation: last-index derives-from an integer count decreased-by 1
 35:                 derivation: char-code  derives-from an integer stack char-at last-index
 36:                 char-code utilizes char-from-code
 37: 
 38: -- The core relocation logic.
 39: the effect behavior called relocate-stack
 40:     with intent: move a hierarchy of items while visualizing the state
 41:     takes:
 42:         an integer called hierarchy-size
 43:         a string called source-name      via observation
 44:         a string called source-items
 45:         a string called destination-name via observation
 46:         a string called destination-items
 47:         a string called transit-name     via observation
 48:         a string called transit-items
 49:     delivers: a tuple of (a string : a string : a string)
 50:     with diminishing: hierarchy-size
 51:     as:
 52:         if hierarchy-size matches 0
 53:             then (source-items : destination-items : transit-items)
 54:             else
 55:                 derivation: sub-stack-size derives-from an integer hierarchy-size decreased-by 1
 56:                 
 57:                 -- PHASE 1: Move the sub-stack to the Transit Depot
 58:                 derivation: phase1-state derives-from sub-stack-size utilizes relocate-stack source-name source-items transit-name transit-items destination-name destination-items
 59:                 
 60:                 derivation: s1 derives-from phase1-state char-at 0
 61:                 derivation: t1 derives-from phase1-state char-at 1
 62:                 derivation: d1 derives-from phase1-state char-at 2
 63:                 
 64:                 -- PHASE 2: Move the Anchor Disk to the Final Depot
 65:                 derivation: anchor   derives-from s1 utilizes identify-top-item
 66:                 derivation: s1-dup   derives-from s1 duplicated-as
 67:                 derivation: s2       derives-from s1-dup utilizes init-of
 68:                 derivation: d2       derives-from a string d1 joined-with anchor
 69:                 
 70:                 derivation: divider  derives-from a string "═══════════════════════════════════════════"
 71:                 derivation: dump1    derives-from nothing broadcasts divider
 72:                 derivation: msg      derives-from a string "Relocating [" joined-with anchor
 73:                 derivation: msg2     derives-from a string msg joined-with "] from "
 74:                 derivation: msg3     derives-from a string msg2 joined-with source-name
 75:                 derivation: msg4     derives-from a string msg3 joined-with " to "
 76:                 derivation: report   derives-from a string msg4 joined-with destination-name
 77:                 derivation: dump2    derives-from nothing broadcasts report
 78:                 
 79:                 derivation: dump3    derives-from nothing source-name utilizes inspect-depot s2
 80:                 derivation: dump4    derives-from nothing destination-name utilizes inspect-depot d2
 81:                 derivation: dump5    derives-from nothing transit-name utilizes inspect-depot t1
 82:                 
 83:                 -- PHASE 3: Bring the sub-stack from Transit to the Final Depot
 84:                 derivation: phase3-state derives-from sub-stack-size utilizes relocate-stack transit-name t1 destination-name d2 source-name s2
 85:                 
 86:                 derivation: t3 derives-from phase3-state char-at 0
 87:                 derivation: d3 derives-from phase3-state char-at 1
 88:                 derivation: s3 derives-from phase3-state char-at 2
 89:                 
 90:                 (s3 : d3 : t3)
 91: 
 92: the effect behavior called run
 93:     with intent: execute the grand relocation plan
 94:     takes: nothing
 95:     delivers: nothing
 96:     as:
 97:         derivation: depot-a-start derives-from a string "321"
 98:         derivation: depot-b-start derives-from a string ""
 99:         derivation: depot-c-start derives-from a string ""
100:         
101:         derivation: d1 derives-from nothing broadcasts "COMMENCING LOGISTICS DISCOURSE:"
102:         derivation: d2 derives-from nothing (a string "Depot-A") utilizes inspect-depot depot-a-start
103:         derivation: d3 derives-from nothing (a string "Depot-C") utilizes inspect-depot depot-c-start
104:         derivation: d4 derives-from nothing (a string "Depot-B") utilizes inspect-depot depot-b-start
105:         
106:         derivation: final-state derives-from 3 utilizes relocate-stack (a string "Depot-A") depot-a-start (a string "Depot-C") depot-c-start (a string "Depot-B") depot-b-start
107:         
108:         derivation: d5 derives-from nothing broadcasts "═══════════════════════════════════════════"
109:         derivation: d6 derives-from nothing broadcasts "RELOCATION COMPLETE."
110:         nothing
</file>

<file path="samples/hello_world_int.onu">
1: the effect behavior called main
2:     receiving: nothing
3:     delivers: nothing
4:     as:
5:         broadcasts "Hello, World!"
</file>

<file path="samples/hello_world.onu">
 1: the module called GlobalBroadcast
 2:     with concern: initial greeting
 3: 
 4: -- This is the first discourse encountered by many researchers.
 5: the effect behavior called run
 6:     with intent: deliver a greeting to the external environment
 7:     takes: nothing
 8:     delivers: nothing
 9:     as:
10:         broadcasts "Hello, World!"
</file>

<file path="samples/illegal_shared.onu">
 1: the module called SharedStateModule
 2:     with concern: testing shared state
 3: 
 4: -- This is ILLEGAL: derivations cannot exist at the module level.
 5: derivation: global-counter derives-from 0
 6: 
 7: the behavior called main
 8:     takes: nothing
 9:     delivers: nothing
10:     as:
11:         global-counter added-to 1
</file>

<file path="samples/map_bench.onu">
 1: the module called MapBenchmark
 2:     with concern: testing dynamic collections
 3: 
 4: the behavior called insert-loop
 5:     with intent: populate the map recursively
 6:     takes:
 7:         a map of (integer : integer) called m
 8:         an integer called current
 9:         an integer called target
10:     delivers: a map of (integer : integer)
11:     with no guaranteed termination
12:     as:
13:         if current matches target
14:             then m
15:             else
16:                 derivation: next-map derives-from m associated-with current current
17:                 next-map utilizes insert-loop (current added-to 1) target
18: 
19: the effect behavior called run
20:     takes: nothing
21:     delivers: nothing
22:     as:
23:         derivation: initial-map derives-from creates-map
24:         derivation: limit derives-from 10000000
25:         derivation: final-map derives-from initial-map utilizes insert-loop 0 limit
26:         broadcasts "Map Populated."
27:         nothing
</file>

<file path="samples/mutation.onu">
 1: the behavior called repeat-text
 2:     with intent: create a large string efficiently using doubling
 3:     takes:
 4:         a string called input
 5:         an integer called count
 6:     delivers: a string
 7:     as:
 8:         if count matches 0
 9:             then ""
10:             else if count matches 1
11:                 then input
12:                 else
13:                     derivation: half derives-from count partitions-by 2
14:                     derivation: rem  derives-from count decreased-by (half scales-by 2)
15:                     
16:                     derivation: base derives-from (input utilizes duplicated-as) receiving repeat-text half
17:                     derivation: doubled derives-from (base utilizes duplicated-as) joined-with base
18:                     
19:                     if rem matches 0
20:                         then doubled
21:                         else doubled joined-with input
22: 
23: the behavior called transform-at
24:     takes:
25:         a string called buf
26:         an integer called index
27:         an integer called total
28:     delivers: a string
29:     as:
30:         if index matches total
31:             then buf
32:             else
33:                 derivation: current derives-from buf char-at index
34:                 derivation: updated derives-from current added-to 1
35:                 derivation: next-buf derives-from buf utilizes set-char index updated
36:                 
37:                 next-buf utilizes transform-at (index added-to 1) total
38: 
39: the effect behavior called run
40:     takes: nothing
41:     delivers: nothing
42:     as:
43:         -- Create a string of 1,000,000 'A's
44:         derivation: base derives-from "A" receiving repeat-text 1000000
45:         
46:         -- Perform 1,000,000 recursive transformations
47:         derivation: result derives-from base utilizes transform-at 0 1000000
48:         broadcasts "Done"
49:         nothing
</file>

<file path="samples/parity.onu">
 1: -- ═══════════════════════════════════════════════════════════════════════════
 2: -- Discourse Unit: The Dance of Parity (Even and Odd)
 3: -- Concern: Mutual recursion and alternating states.
 4: --
 5: -- Parity is an alternating property. A number is even if its predecessor 
 6: -- is odd, and odd if its predecessor is even.
 7: -- 1. The Equilibrium: Zero is the origin of Even (1).
 8: -- 2. The Alternation: We determine state by asking the opposite question 
 9: --                      of the number that came before.
10: -- ═══════════════════════════════════════════════════════════════════════════
11: 
12: the module called ParityLogic
13:     with concern: mutual recursive verification
14: 
15: -- Rule 1: Origin of Even
16: the behavior called is-even
17:     with intent: determine if a number maintains even equilibrium
18:     takes:
19:         an integer called n
20:     delivers: an integer
21:     with diminishing: n
22:     as:
23:         if n matches 0
24:             then 1
25:             else (n decreased-by 1) utilizes is-odd
26: 
27: -- Rule 2: Origin of Odd
28: the behavior called is-odd
29:     with intent: determine if a number maintains odd alternation
30:     takes:
31:         an integer called n
32:     delivers: an integer
33:     with diminishing: n
34:     as:
35:         if n matches 0
36:             then 0
37:             else (n decreased-by 1) utilizes is-even
38: 
39: the effect behavior called run
40:     with intent: demonstrate the dance of parity
41:     takes: nothing
42:     delivers: nothing
43:     as:
44:         derivation: target1 derives-from an integer 10
45:         derivation: target2 derives-from an integer 7
46:         
47:         derivation: res1 derives-from target1 utilizes is-even
48:         derivation: res2 derives-from target2 utilizes is-even
49:         
50:         derivation: d1 derives-from nothing broadcasts "PARITY VERIFICATION:"
51:         derivation: m1 derives-from a string "Is 10 even? (1=yes): " joined-with (res1 utilizes as-text)
52:         derivation: d2 derives-from nothing broadcasts m1
53:         
54:         derivation: m2 derives-from a string "Is 7 even?  (1=yes): " joined-with (res2 utilizes as-text)
55:         derivation: d3 derives-from nothing broadcasts m2
56:         nothing
</file>

<file path="samples/sample.onu">
 1: the module called ResearchSample
 2:     with concern: demonstrating simple derivation
 3: 
 4: -- A basic example of how local state is derived and delivered.
 5: the behavior called example-derivation
 6:     with intent: derive a constant value and deliver it
 7:     takes:
 8:         an integer called x
 9:     delivers: an integer
10:     as:
11:         derivation: constant derives-from an integer 10
12:         constant
13: 
14: the effect behavior called run
15:     takes: nothing
16:     delivers: nothing
17:     as:
18:         derivation: result derives-from an integer 5 utilizes example-derivation
19:         broadcasts result
</file>

<file path="samples/svo_e2e.onu">
 1: the module called EndToEndModule
 2:     with concern: validating the full pipeline
 3: 
 4: the effect behavior called greet
 5:     with intent: display a formatted greeting
 6:     takes:
 7:         a string called name via observation
 8:     delivers: nothing
 9:     as:
10:         derivation: msg derives-from "Greetings, "
11:         derivation: full derives-from msg joined-with name
12:         broadcasts full
13: 
14: the effect behavior called main
15:     with intent: entry point
16:     takes: nothing
17:     delivers: nothing
18:     as:
19:         "Conductor" utilizes greet
</file>

<file path="samples/tui_demo.onu">
 1: the module called TuiModule
 2:     with concern: terminal user interface experimentation
 3: 
 4: the behavior called sleep-loop
 5:     takes:
 6:         an integer called count
 7:     delivers: nothing
 8:     as:
 9:         if count matches 0
10:             then nothing
11:             else (count decreased-by 1) utilizes sleep-loop
12: 
13: the behavior called draw-sprite
14:     takes:
15:         an integer called x
16:         an integer called limit
17:     delivers: nothing
18:     with no guaranteed termination
19:     as:
20:         if x exceeds limit
21:             then nothing
22:             else
23:                 -- ANSI: Clear Screen (\x1b[2J) and Home Cursor (\x1b[H)
24:                 derivation: d1 derives-from nothing broadcasts "\x1b[2J\x1b[H"
25:                 
26:                 -- Move cursor to column x
27:                 derivation: pos derives-from "\x1b[1;" joined-with (x utilizes as-text)
28:                 derivation: pos2 derives-from pos joined-with "H"
29:                 derivation: d2 derives-from nothing broadcasts pos2
30:                 
31:                 -- Draw the sprite
32:                 derivation: d3 derives-from nothing broadcasts "@"
33:                 
34:                 -- Wait a bit (primitive sleep)
35:                 derivation: d4 derives-from nothing 10000000 utilizes sleep-loop
36:                 
37:                 (x added-to 1) utilizes draw-sprite limit
38: 
39: the effect behavior called run
40:     takes: nothing
41:     delivers: nothing
42:     as:
43:         0 utilizes draw-sprite 40
44:         nothing
</file>

<file path="tests/samples_test.rs">
 1: use onu_refactor::CompilationPipeline;
 2: use onu_refactor::infrastructure::os::NativeOsEnvironment;
 3: use onu_refactor::adapters::codegen::OnuCodegen;
 4: use onu_refactor::application::options::{CompilationOptions, LogLevel};
 5: use std::process::Command;
 6: use std::path::Path;
 7: fn run_sample_test(sample_name: &str) {
 8:     let mut options = CompilationOptions::default();
 9:     options.log_level = LogLevel::Trace;
10:     options.emit_hir = true;
11:     options.emit_tokens = true;
12:     let env = NativeOsEnvironment::new(options.log_level);
13:     let codegen = OnuCodegen::new(options.log_level);
14:     let mut pipeline = CompilationPipeline::new(env, codegen, options);
15:     let sample_path = format!("samples/{}.onu", sample_name);
16:     assert!(Path::new(&sample_path).exists(), "Sample file not found: {}", sample_path);
17:     pipeline.compile(&sample_path).expect(&format!("Failed to compile {}", sample_name));
18:     let prog_path = format!("./{}_bin", sample_name);
19:     let output = Command::new(&prog_path)
20:         .output()
21:         .expect(&format!("Failed to execute {}", sample_name));
22:     assert!(output.status.success(), "Execution of {} failed. Output: {}", sample_name, String::from_utf8_lossy(&output.stderr));
23: }
24: macro_rules! sample_test {
25:     ($name:ident) => {
26:         #[test]
27:         fn $name() {
28:             run_sample_test(stringify!($name));
29:         }
30:     };
31: }
32: sample_test!(hello_world);
33: sample_test!(factorial);
34: sample_test!(fibonacci);
35: sample_test!(parity);
36: sample_test!(sample);
</file>

<file path=".gitignore">
1: /target
</file>

<file path="Cargo.toml">
1: [package]
2: name = "onu_refactor"
3: version = "0.1.0"
4: edition = "2024"
5: 
6: [dependencies]
7: chrono = { version = "0.4.44", features = ["serde"] }
8: either = "1.15.0"
9: inkwell = { version = "0.8.0", features = ["llvm14-0"] }
</file>

<file path="collatz.ll">
 1: ; ModuleID = 'onu_discourse'
 2: source_filename = "onu_discourse"
 3: 
 4: @strtmp = private unnamed_addr constant [42 x i8] c"COLLATZ SEQUENCE (Starting at 1,000,000):\00", align 1
 5: 
 6: define void @broadcast_sequence(i64 %0, i64 %1) {
 7: entry:
 8:   %v3 = alloca { i64, i8* }, align 8
 9:   %v2 = alloca i64, align 8
10:   %n = alloca i64, align 8
11:   store i64 %0, i64* %n, align 4
12:   %terms-remaining = alloca i64, align 8
13:   store i64 %1, i64* %terms-remaining, align 4
14:   br label %bb0
15: 
16: bb0:                                              ; preds = %entry
17:   store i64 0, i64* %v2, align 4
18:   %v0 = load i64, i64* %n, align 4
19:   %calltmp = call { i64, i8* } @as-text(i64 %v0)
20:   store { i64, i8* } %calltmp, { i64, i8* }* %v3, align 8
21:   %v31 = load { i64, i8* }, { i64, i8* }* %v3, align 8
22:   %raw_ptr = extractvalue { i64, i8* } %v31, 1
23:   call void @broadcasts(i8* %raw_ptr)
24:   ret void
25: }
26: 
27: define i32 @main(i32 %0, i8** %1) {
28: entry:
29:   %v2 = alloca i64, align 8
30:   %__argc = alloca i32, align 4
31:   store i32 %0, i32* %__argc, align 4
32:   %__argv = alloca i8**, align 8
33:   store i8** %1, i8*** %__argv, align 8
34:   br label %bb0
35: 
36: bb0:                                              ; preds = %entry
37:   store i64 0, i64* %v2, align 4
38:   call void @broadcasts(i8* getelementptr inbounds ([42 x i8], [42 x i8]* @strtmp, i32 0, i32 0))
39:   ret i32 0
40: }
41: 
42: declare { i64, i8* } @as-text(i64)
43: 
44: declare void @broadcasts(i8*)
</file>

<file path="factorial.ll">
  1: ; ModuleID = 'onu_discourse'
  2: source_filename = "onu_discourse"
  3: 
  4: @strtmp = private unnamed_addr constant [33 x i8] c"The accumulation of 5 steps is: \00", align 1
  5: 
  6: define i64 @terminal_seed() {
  7: entry:
  8:   br label %bb0
  9: 
 10: bb0:                                              ; preds = %entry
 11:   ret i64 1
 12: }
 13: 
 14: define i64 @calculate_accumulation(i64 %0) {
 15: entry:
 16:   %v8 = alloca i64, align 8
 17:   %v7 = alloca i64, align 8
 18:   %v6 = alloca i64, align 8
 19:   %v5 = alloca i64, align 8
 20:   %v4 = alloca i64, align 8
 21:   %v2 = alloca i64, align 8
 22:   %v3 = alloca i64, align 8
 23:   %v1 = alloca i64, align 8
 24:   %current_value = alloca i64, align 8
 25:   store i64 %0, i64* %current_value, align 4
 26:   br label %bb0
 27: 
 28: bb0:                                              ; preds = %entry
 29:   %v0 = load i64, i64* %current_value, align 4
 30:   %calltmp = call i64 @matches(i64 %v0, i64 0)
 31:   store i64 %calltmp, i64* %v1, align 4
 32:   %v11 = load i64, i64* %v1, align 4
 33:   %bool_cast = icmp ne i64 %v11, 0
 34:   br i1 %bool_cast, label %bb1, label %bb2
 35: 
 36: bb1:                                              ; preds = %bb0
 37:   %calltmp2 = call i64 @terminal_seed()
 38:   store i64 %calltmp2, i64* %v3, align 4
 39:   %v33 = load i64, i64* %v3, align 4
 40:   store i64 %v33, i64* %v2, align 4
 41:   br label %bb3
 42: 
 43: bb2:                                              ; preds = %bb0
 44:   %v04 = load i64, i64* %current_value, align 4
 45:   %calltmp5 = call i64 @decreased_by(i64 %v04, i64 1)
 46:   store i64 %calltmp5, i64* %v4, align 4
 47:   %v46 = load i64, i64* %v4, align 4
 48:   store i64 %v46, i64* %v5, align 4
 49:   %v57 = load i64, i64* %v5, align 4
 50:   %calltmp8 = call i64 @calculate_accumulation(i64 %v57)
 51:   store i64 %calltmp8, i64* %v6, align 4
 52:   %v69 = load i64, i64* %v6, align 4
 53:   store i64 %v69, i64* %v7, align 4
 54:   %v010 = load i64, i64* %current_value, align 4
 55:   %v711 = load i64, i64* %v7, align 4
 56:   %calltmp12 = call i64 @scales_by(i64 %v010, i64 %v711)
 57:   store i64 %calltmp12, i64* %v8, align 4
 58:   %v813 = load i64, i64* %v8, align 4
 59:   store i64 %v813, i64* %v2, align 4
 60:   br label %bb3
 61: 
 62: bb3:                                              ; preds = %bb2, %bb1
 63:   %v214 = load i64, i64* %v2, align 4
 64:   ret i64 %v214
 65: }
 66: 
 67: define i32 @main(i32 %0, i8** %1) {
 68: entry:
 69:   %v8 = alloca i64, align 8
 70:   %v7 = alloca i64, align 8
 71:   %v6 = alloca i64, align 8
 72:   %v5 = alloca { i64, i8* }, align 8
 73:   %v4 = alloca i64, align 8
 74:   %v3 = alloca i64, align 8
 75:   %v2 = alloca i64, align 8
 76:   %__argc = alloca i32, align 4
 77:   store i32 %0, i32* %__argc, align 4
 78:   %__argv = alloca i8**, align 8
 79:   store i8** %1, i8*** %__argv, align 8
 80:   br label %bb0
 81: 
 82: bb0:                                              ; preds = %entry
 83:   store i64 5, i64* %v2, align 4
 84:   %v21 = load i64, i64* %v2, align 4
 85:   %calltmp = call i64 @calculate_accumulation(i64 %v21)
 86:   store i64 %calltmp, i64* %v3, align 4
 87:   %v32 = load i64, i64* %v3, align 4
 88:   store i64 %v32, i64* %v4, align 4
 89:   store { i64, i8* } { i64 32, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @strtmp, i32 0, i32 0) }, { i64, i8* }* %v5, align 8
 90:   store i64 0, i64* %v6, align 4
 91:   %v53 = load { i64, i8* }, { i64, i8* }* %v5, align 8
 92:   %raw_ptr = extractvalue { i64, i8* } %v53, 1
 93:   call void @broadcasts(i8* %raw_ptr)
 94:   store i64 0, i64* %v7, align 4
 95:   %v44 = load i64, i64* %v4, align 4
 96:   %calltmp5 = call i64 @as_text(i64 %v44)
 97:   store i64 %calltmp5, i64* %v8, align 4
 98:   %v86 = load i64, i64* %v8, align 4
 99:   %ptr_cast = inttoptr i64 %v86 to i8*
100:   call void @broadcasts(i8* %ptr_cast)
101:   ret i32 0
102: }
103: 
104: declare i64 @matches(i64, i64)
105: 
106: declare i64 @decreased_by(i64, i64)
107: 
108: declare i64 @scales_by(i64, i64)
109: 
110: declare void @broadcasts(i8*)
111: 
112: declare i64 @as_text(i64)
</file>

<file path="fibonacci.ll">
  1: ; ModuleID = 'onu_discourse'
  2: source_filename = "onu_discourse"
  3: 
  4: @strtmp = private unnamed_addr constant [30 x i8] c"The population at generation \00", align 1
  5: 
  6: define i64 @origin_size() {
  7: entry:
  8:   br label %bb0
  9: 
 10: bb0:                                              ; preds = %entry
 11:   ret i64 0
 12: }
 13: 
 14: define i64 @spark_size() {
 15: entry:
 16:   br label %bb0
 17: 
 18: bb0:                                              ; preds = %entry
 19:   ret i64 1
 20: }
 21: 
 22: define i64 @calculate_growth(i64 %0) {
 23: entry:
 24:   %v16 = alloca i64, align 8
 25:   %v15 = alloca i64, align 8
 26:   %v14 = alloca i64, align 8
 27:   %v13 = alloca i64, align 8
 28:   %v12 = alloca i64, align 8
 29:   %v1119 = alloca i64, align 8
 30:   %v10 = alloca i64, align 8
 31:   %v9 = alloca i64, align 8
 32:   %v8 = alloca i64, align 8
 33:   %v6 = alloca i64, align 8
 34:   %v7 = alloca i64, align 8
 35:   %v5 = alloca i64, align 8
 36:   %v4 = alloca i64, align 8
 37:   %v2 = alloca i64, align 8
 38:   %v3 = alloca i64, align 8
 39:   %v1 = alloca i64, align 8
 40:   %generation = alloca i64, align 8
 41:   store i64 %0, i64* %generation, align 4
 42:   br label %bb0
 43: 
 44: bb0:                                              ; preds = %entry
 45:   %v0 = load i64, i64* %generation, align 4
 46:   %calltmp = call i64 @matches(i64 %v0, i64 0)
 47:   store i64 %calltmp, i64* %v1, align 4
 48:   %v11 = load i64, i64* %v1, align 4
 49:   %bool_cast = icmp ne i64 %v11, 0
 50:   br i1 %bool_cast, label %bb1, label %bb2
 51: 
 52: bb1:                                              ; preds = %bb0
 53:   %calltmp2 = call i64 @origin_size()
 54:   store i64 %calltmp2, i64* %v3, align 4
 55:   %v33 = load i64, i64* %v3, align 4
 56:   store i64 %v33, i64* %v2, align 4
 57:   br label %bb3
 58: 
 59: bb2:                                              ; preds = %bb0
 60:   %v04 = load i64, i64* %generation, align 4
 61:   %calltmp5 = call i64 @decreased_by(i64 %v04, i64 1)
 62:   store i64 %calltmp5, i64* %v4, align 4
 63:   %v46 = load i64, i64* %v4, align 4
 64:   %calltmp7 = call i64 @matches(i64 %v46, i64 0)
 65:   store i64 %calltmp7, i64* %v5, align 4
 66:   %v58 = load i64, i64* %v5, align 4
 67:   %bool_cast9 = icmp ne i64 %v58, 0
 68:   br i1 %bool_cast9, label %bb4, label %bb5
 69: 
 70: bb3:                                              ; preds = %bb6, %bb1
 71:   %v210 = load i64, i64* %v2, align 4
 72:   ret i64 %v210
 73: 
 74: bb4:                                              ; preds = %bb2
 75:   %calltmp11 = call i64 @spark_size()
 76:   store i64 %calltmp11, i64* %v7, align 4
 77:   %v712 = load i64, i64* %v7, align 4
 78:   store i64 %v712, i64* %v6, align 4
 79:   br label %bb6
 80: 
 81: bb5:                                              ; preds = %bb2
 82:   %v013 = load i64, i64* %generation, align 4
 83:   %calltmp14 = call i64 @decreased_by(i64 %v013, i64 1)
 84:   store i64 %calltmp14, i64* %v8, align 4
 85:   %v815 = load i64, i64* %v8, align 4
 86:   store i64 %v815, i64* %v9, align 4
 87:   %v016 = load i64, i64* %generation, align 4
 88:   %calltmp17 = call i64 @decreased_by(i64 %v016, i64 2)
 89:   store i64 %calltmp17, i64* %v10, align 4
 90:   %v1018 = load i64, i64* %v10, align 4
 91:   store i64 %v1018, i64* %v1119, align 4
 92:   %v920 = load i64, i64* %v9, align 4
 93:   %calltmp21 = call i64 @calculate_growth(i64 %v920)
 94:   store i64 %calltmp21, i64* %v12, align 4
 95:   %v1222 = load i64, i64* %v12, align 4
 96:   store i64 %v1222, i64* %v13, align 4
 97:   %v1123 = load i64, i64* %v1119, align 4
 98:   %calltmp24 = call i64 @calculate_growth(i64 %v1123)
 99:   store i64 %calltmp24, i64* %v14, align 4
100:   %v1425 = load i64, i64* %v14, align 4
101:   store i64 %v1425, i64* %v15, align 4
102:   %v1326 = load i64, i64* %v13, align 4
103:   %v1527 = load i64, i64* %v15, align 4
104:   %calltmp28 = call i64 @added_to(i64 %v1326, i64 %v1527)
105:   store i64 %calltmp28, i64* %v16, align 4
106:   %v1629 = load i64, i64* %v16, align 4
107:   store i64 %v1629, i64* %v6, align 4
108:   br label %bb6
109: 
110: bb6:                                              ; preds = %bb5, %bb4
111:   %v630 = load i64, i64* %v6, align 4
112:   store i64 %v630, i64* %v2, align 4
113:   br label %bb3
114: }
115: 
116: define i32 @main(i32 %0, i8** %1) {
117: entry:
118:   %v11 = alloca i64, align 8
119:   %v10 = alloca i64, align 8
120:   %v9 = alloca i64, align 8
121:   %v8 = alloca { i64, i8* }, align 8
122:   %v7 = alloca i64, align 8
123:   %v6 = alloca i64, align 8
124:   %v5 = alloca { i64, i8* }, align 8
125:   %v4 = alloca i64, align 8
126:   %v3 = alloca i64, align 8
127:   %v2 = alloca i64, align 8
128:   %__argc = alloca i32, align 4
129:   store i32 %0, i32* %__argc, align 4
130:   %__argv = alloca i8**, align 8
131:   store i8** %1, i8*** %__argv, align 8
132:   br label %bb0
133: 
134: bb0:                                              ; preds = %entry
135:   store i64 40, i64* %v2, align 4
136:   %v21 = load i64, i64* %v2, align 4
137:   %calltmp = call i64 @calculate_growth(i64 %v21)
138:   store i64 %calltmp, i64* %v3, align 4
139:   %v32 = load i64, i64* %v3, align 4
140:   store i64 %v32, i64* %v4, align 4
141:   store { i64, i8* } { i64 29, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @strtmp, i32 0, i32 0) }, { i64, i8* }* %v5, align 8
142:   %calltmp3 = call i64 @joined_with()
143:   store i64 %calltmp3, i64* %v6, align 4
144:   %v24 = load i64, i64* %v2, align 4
145:   %calltmp5 = call i64 @as_text(i64 %v24)
146:   store i64 %calltmp5, i64* %v7, align 4
147:   %v56 = load { i64, i8* }, { i64, i8* }* %v5, align 8
148:   store { i64, i8* } %v56, { i64, i8* }* %v8, align 8
149:   %calltmp7 = call i64 @joined_with()
150:   store i64 %calltmp7, i64* %v9, align 4
151:   store i64 0, i64* %v10, align 4
152:   %v88 = load { i64, i8* }, { i64, i8* }* %v8, align 8
153:   %raw_ptr = extractvalue { i64, i8* } %v88, 1
154:   call void @broadcasts(i8* %raw_ptr)
155:   %v49 = load i64, i64* %v4, align 4
156:   %calltmp10 = call i64 @as_text(i64 %v49)
157:   store i64 %calltmp10, i64* %v11, align 4
158:   %v1111 = load i64, i64* %v11, align 4
159:   %ptr_cast = inttoptr i64 %v1111 to i8*
160:   call void @broadcasts(i8* %ptr_cast)
161:   ret i32 0
162: }
163: 
164: declare i64 @matches(i64, i64)
165: 
166: declare i64 @decreased_by(i64, i64)
167: 
168: declare i64 @added_to(i64, i64)
169: 
170: declare i64 @joined_with()
171: 
172: declare i64 @as_text(i64)
173: 
174: declare void @broadcasts(i8*)
</file>

<file path="hello_world.ll">
 1: ; ModuleID = 'onu_discourse'
 2: source_filename = "onu_discourse"
 3: 
 4: @strtmp = private unnamed_addr constant [14 x i8] c"Hello, World!\00", align 1
 5: 
 6: define i32 @main(i32 %0, i8** %1) {
 7: entry:
 8:   %__argc = alloca i32, align 4
 9:   store i32 %0, i32* %__argc, align 4
10:   %__argv = alloca i8**, align 8
11:   store i8** %1, i8*** %__argv, align 8
12:   br label %bb0
13: 
14: bb0:                                              ; preds = %entry
15:   call void @broadcasts(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @strtmp, i32 0, i32 0))
16:   ret i32 0
17: }
18: 
19: declare void @broadcasts(i8*)
</file>

<file path="output.ll">
 1: ; ModuleID = 'onu_discourse'
 2: source_filename = "onu_discourse"
 3: 
 4: declare void @onu_broadcast({ i64, i8* }*)
 5: 
 6: declare i64 @as_text(i64)
 7: 
 8: define void @example_derivation(i64 %0) {
 9: bb0:
10:   %x = alloca i64, align 8
11:   store i64 %0, i64* %x, align 4
12:   ret void
13: }
14: 
15: define void @main(i32 %0, i64 %1) {
16: bb0:
17:   %__argc = alloca i32, align 4
18:   store i32 %0, i32* %__argc, align 4
19:   %__argv = alloca i64, align 8
20:   store i64 %1, i64* %__argv, align 4
21:   %v0 = load i32, i32* %__argc, align 4
22:   %ptr = inttoptr i32 %v0 to i8*
23:   %data = insertvalue { i64, i8* } { i64 0, i8* undef }, i8* %ptr, 1
24:   %fake_emit_tmp = alloca { i64, i8* }, align 8
25:   store { i64, i8* } %data, { i64, i8* }* %fake_emit_tmp, align 8
26:   call void @onu_broadcast({ i64, i8* }* %fake_emit_tmp)
27:   ret void
28: }
</file>

<file path="parity.ll">
  1: ; ModuleID = 'onu_discourse'
  2: source_filename = "onu_discourse"
  3: 
  4: @strtmp = private unnamed_addr constant [21 x i8] c"PARITY VERIFICATION:\00", align 1
  5: @strtmp.1 = private unnamed_addr constant [22 x i8] c"Is 10 even? (1=yes): \00", align 1
  6: @strtmp.2 = private unnamed_addr constant [22 x i8] c"Is 7 even?  (1=yes): \00", align 1
  7: 
  8: define i64 @is_even(i64 %0) {
  9: entry:
 10:   %v4 = alloca i64, align 8
 11:   %v3 = alloca i64, align 8
 12:   %v2 = alloca i64, align 8
 13:   %v1 = alloca i64, align 8
 14:   %n = alloca i64, align 8
 15:   store i64 %0, i64* %n, align 4
 16:   br label %bb0
 17: 
 18: bb0:                                              ; preds = %entry
 19:   %v0 = load i64, i64* %n, align 4
 20:   %calltmp = call i64 @matches(i64 %v0, i64 0)
 21:   store i64 %calltmp, i64* %v1, align 4
 22:   %v11 = load i64, i64* %v1, align 4
 23:   %bool_cast = icmp ne i64 %v11, 0
 24:   br i1 %bool_cast, label %bb1, label %bb2
 25: 
 26: bb1:                                              ; preds = %bb0
 27:   store i64 1, i64* %v2, align 4
 28:   br label %bb3
 29: 
 30: bb2:                                              ; preds = %bb0
 31:   %v02 = load i64, i64* %n, align 4
 32:   %calltmp3 = call i64 @decreased_by(i64 %v02, i64 1)
 33:   store i64 %calltmp3, i64* %v3, align 4
 34:   %v34 = load i64, i64* %v3, align 4
 35:   %calltmp5 = call i64 @is_odd(i64 %v34)
 36:   store i64 %calltmp5, i64* %v4, align 4
 37:   %v46 = load i64, i64* %v4, align 4
 38:   store i64 %v46, i64* %v2, align 4
 39:   br label %bb3
 40: 
 41: bb3:                                              ; preds = %bb2, %bb1
 42:   %v27 = load i64, i64* %v2, align 4
 43:   ret i64 %v27
 44: }
 45: 
 46: define i64 @is_odd(i64 %0) {
 47: entry:
 48:   %v4 = alloca i64, align 8
 49:   %v3 = alloca i64, align 8
 50:   %v2 = alloca i64, align 8
 51:   %v1 = alloca i64, align 8
 52:   %n = alloca i64, align 8
 53:   store i64 %0, i64* %n, align 4
 54:   br label %bb0
 55: 
 56: bb0:                                              ; preds = %entry
 57:   %v0 = load i64, i64* %n, align 4
 58:   %calltmp = call i64 @matches(i64 %v0, i64 0)
 59:   store i64 %calltmp, i64* %v1, align 4
 60:   %v11 = load i64, i64* %v1, align 4
 61:   %bool_cast = icmp ne i64 %v11, 0
 62:   br i1 %bool_cast, label %bb1, label %bb2
 63: 
 64: bb1:                                              ; preds = %bb0
 65:   store i64 0, i64* %v2, align 4
 66:   br label %bb3
 67: 
 68: bb2:                                              ; preds = %bb0
 69:   %v02 = load i64, i64* %n, align 4
 70:   %calltmp3 = call i64 @decreased_by(i64 %v02, i64 1)
 71:   store i64 %calltmp3, i64* %v3, align 4
 72:   %v34 = load i64, i64* %v3, align 4
 73:   %calltmp5 = call i64 @is_even(i64 %v34)
 74:   store i64 %calltmp5, i64* %v4, align 4
 75:   %v46 = load i64, i64* %v4, align 4
 76:   store i64 %v46, i64* %v2, align 4
 77:   br label %bb3
 78: 
 79: bb3:                                              ; preds = %bb2, %bb1
 80:   %v27 = load i64, i64* %v2, align 4
 81:   ret i64 %v27
 82: }
 83: 
 84: define i32 @main(i32 %0, i8** %1) {
 85: entry:
 86:   %v16 = alloca i64, align 8
 87:   %v15 = alloca i64, align 8
 88:   %v14 = alloca i64, align 8
 89:   %v13 = alloca { i64, i8* }, align 8
 90:   %v12 = alloca i64, align 8
 91:   %v11 = alloca i64, align 8
 92:   %v10 = alloca i64, align 8
 93:   %v9 = alloca { i64, i8* }, align 8
 94:   %v8 = alloca i64, align 8
 95:   %v7 = alloca i64, align 8
 96:   %v6 = alloca i64, align 8
 97:   %v5 = alloca i64, align 8
 98:   %v4 = alloca i64, align 8
 99:   %v3 = alloca i64, align 8
100:   %v2 = alloca i64, align 8
101:   %__argc = alloca i32, align 4
102:   store i32 %0, i32* %__argc, align 4
103:   %__argv = alloca i8**, align 8
104:   store i8** %1, i8*** %__argv, align 8
105:   br label %bb0
106: 
107: bb0:                                              ; preds = %entry
108:   store i64 10, i64* %v2, align 4
109:   store i64 7, i64* %v3, align 4
110:   %v21 = load i64, i64* %v2, align 4
111:   %calltmp = call i64 @is_even(i64 %v21)
112:   store i64 %calltmp, i64* %v4, align 4
113:   %v42 = load i64, i64* %v4, align 4
114:   store i64 %v42, i64* %v5, align 4
115:   %v33 = load i64, i64* %v3, align 4
116:   %calltmp4 = call i64 @is_even(i64 %v33)
117:   store i64 %calltmp4, i64* %v6, align 4
118:   %v65 = load i64, i64* %v6, align 4
119:   store i64 %v65, i64* %v7, align 4
120:   store i64 0, i64* %v8, align 4
121:   call void @broadcasts(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @strtmp, i32 0, i32 0))
122:   store { i64, i8* } { i64 21, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @strtmp.1, i32 0, i32 0) }, { i64, i8* }* %v9, align 8
123:   %calltmp6 = call i64 @joined_with()
124:   store i64 %calltmp6, i64* %v10, align 4
125:   %v57 = load i64, i64* %v5, align 4
126:   %calltmp8 = call i64 @as_text(i64 %v57)
127:   store i64 %calltmp8, i64* %v11, align 4
128:   store i64 0, i64* %v12, align 4
129:   %v99 = load { i64, i8* }, { i64, i8* }* %v9, align 8
130:   %raw_ptr = extractvalue { i64, i8* } %v99, 1
131:   call void @broadcasts(i8* %raw_ptr)
132:   store { i64, i8* } { i64 21, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @strtmp.2, i32 0, i32 0) }, { i64, i8* }* %v13, align 8
133:   %calltmp10 = call i64 @joined_with()
134:   store i64 %calltmp10, i64* %v14, align 4
135:   %v711 = load i64, i64* %v7, align 4
136:   %calltmp12 = call i64 @as_text(i64 %v711)
137:   store i64 %calltmp12, i64* %v15, align 4
138:   store i64 0, i64* %v16, align 4
139:   %v1313 = load { i64, i8* }, { i64, i8* }* %v13, align 8
140:   %raw_ptr14 = extractvalue { i64, i8* } %v1313, 1
141:   call void @broadcasts(i8* %raw_ptr14)
142:   ret i32 0
143: }
144: 
145: declare i64 @matches(i64, i64)
146: 
147: declare i64 @decreased_by(i64, i64)
148: 
149: declare void @broadcasts(i8*)
150: 
151: declare i64 @joined_with()
152: 
153: declare i64 @as_text(i64)
</file>

<file path="runtime.c">
  1: #include <stdio.h>
  2: #include <stdlib.h>
  3: #include <string.h>
  4: typedef struct {
  5:     long long len;
  6:     char* data;
  7: } String;
  8: typedef struct MapEntry {
  9:     void* key;
 10:     void* value;
 11:     unsigned long long hash;
 12:     struct MapEntry* next;
 13: } MapEntry;
 14: typedef struct {
 15:     long long size;
 16:     long long capacity;
 17:     MapEntry** buckets;
 18: } Map;
 19: typedef struct TreeNode {
 20:     void* value;
 21:     struct TreeNode* left;
 22:     struct TreeNode* right;
 23:     long long height;
 24: } TreeNode;
 25: typedef struct {
 26:     TreeNode* root;
 27:     long long size;
 28: } Tree;
 29: void* onu_malloc(size_t size) {
 30:     return malloc(size);
 31: }
 32: void onu_free(void* ptr) {
 33:     if (ptr != NULL) free(ptr);
 34: }
 35: String onu_create_string(const char* s) {
 36:     size_t len = strlen(s);
 37:     char* data = onu_malloc(len + 1);
 38:     memcpy(data, s, len + 1);
 39:     String res = {(long long)len, data};
 40:     return res;
 41: }
 42: String as_text(long long n) __asm__("as-text");
 43: String joined_with(String a, String b) __asm__("joined-with");
 44: long long onu_len(String s) __asm__("len");
 45: long long onu_char_at(String s, long long idx) __asm__("char-at");
 46: String onu_init_of(String s) __asm__("init-of");
 47: String onu_char_from_code(long long code) __asm__("char-from-code");
 48: String onu_strdup(String s) __asm__("duplicated-as");
 49: String onu_set_char(String s, long long idx, long long val) __asm__("set-char");
 50: String onu_inplace_set_char(String s, long long idx, long long val) __asm__("inplace-set-char");
 51: String as_text(long long n) {
 52:     char* buf = onu_malloc(32);
 53:     sprintf(buf, "%lld", n);
 54:     String res = {(long long)strlen(buf), buf};
 55:     return res;
 56: }
 57: String joined_with(String a, String b) {
 58:     char* res_data = onu_malloc(a.len + b.len + 1);
 59:     memcpy(res_data, a.data, a.len);
 60:     memcpy(res_data + a.len, b.data, b.len);
 61:     res_data[a.len + b.len] = '\0';
 62:     String res = {a.len + b.len, res_data};
 63:     return res;
 64: }
 65: long long onu_len(String s) {
 66:     return s.len;
 67: }
 68: long long onu_char_at(String s, long long idx) {
 69:     if (idx < 0 || idx >= s.len) return 0;
 70:     return (long long)s.data[idx];
 71: }
 72: String onu_init_of(String s) {
 73:     if (s.len <= 1) {
 74:         char* empty = onu_malloc(1);
 75:         empty[0] = '\0';
 76:         String res = {0, empty};
 77:         return res;
 78:     }
 79:     char* res_data = onu_malloc(s.len);
 80:     memcpy(res_data, s.data, s.len - 1);
 81:     res_data[s.len - 1] = '\0';
 82:     String res = {s.len - 1, res_data};
 83:     return res;
 84: }
 85: String onu_char_from_code(long long code) {
 86:     char* res_data = onu_malloc(2);
 87:     res_data[0] = (char)code;
 88:     res_data[1] = '\0';
 89:     String res = {1, res_data};
 90:     return res;
 91: }
 92: String onu_strdup(String s) {
 93:     char* res_data = onu_malloc(s.len + 1);
 94:     memcpy(res_data, s.data, s.len + 1);
 95:     String res = {s.len, res_data};
 96:     return res;
 97: }
 98: String onu_set_char(String s, long long idx, long long val) {
 99:     char* res_data = onu_malloc(s.len + 1);
100:     memcpy(res_data, s.data, s.len + 1);
101:     if (idx >= 0 && idx < s.len) {
102:         res_data[idx] = (char)val;
103:     }
104:     String res = {s.len, res_data};
105:     return res;
106: }
107: String onu_inplace_set_char(String s, long long idx, long long val) {
108:     if (idx >= 0 && idx < s.len) {
109:         s.data[idx] = (char)val;
110:     }
111:     return s;
112: }
113: unsigned long long onu_hash(void* key, int is_string) {
114:     if (is_string) {
115:         String* s = (String*)key;
116:         unsigned long long h = 14695981039346656037ULL;
117:         for (long long i = 0; i < s->len; i++) {
118:             h ^= (unsigned char)s->data[i];
119:             h *= 1099511628211ULL;
120:         }
121:         return h;
122:     } else {
123:         return (unsigned long long)key;
124:     }
125: }
126: Map* onu_map_create(long long capacity) {
127:     Map* map = onu_malloc(sizeof(Map));
128:     map->size = 0;
129:     map->capacity = capacity > 0 ? capacity : 16;
130:     map->buckets = onu_malloc(sizeof(MapEntry*) * map->capacity);
131:     memset(map->buckets, 0, sizeof(MapEntry*) * map->capacity);
132:     return map;
133: }
134: void onu_map_resize(Map* map) {
135:     long long old_capacity = map->capacity;
136:     MapEntry** old_buckets = map->buckets;
137:     map->capacity *= 2;
138:     map->buckets = onu_malloc(sizeof(MapEntry*) * map->capacity);
139:     memset(map->buckets, 0, sizeof(MapEntry*) * map->capacity);
140:     for (long long i = 0; i < old_capacity; i++) {
141:         MapEntry* entry = old_buckets[i];
142:         while (entry) {
143:             MapEntry* next = entry->next;
144:             long long new_idx = entry->hash % map->capacity;
145:             entry->next = map->buckets[new_idx];
146:             map->buckets[new_idx] = entry;
147:             entry = next;
148:         }
149:     }
150:     onu_free(old_buckets);
151: }
152: Map* onu_map_insert(Map* map, void* key, void* value, int is_string) {
153:     if (map->size >= map->capacity * 0.75) {
154:         onu_map_resize(map);
155:     }
156:     unsigned long long h = onu_hash(key, is_string);
157:     long long idx = h % map->capacity;
158:     MapEntry* entry = map->buckets[idx];
159:     while (entry) {
160:         int match = 0;
161:         if (is_string) {
162:             String* s1 = (String*)key;
163:             String* s2 = (String*)entry->key;
164:             if (s1->len == s2->len && memcmp(s1->data, s2->data, s1->len) == 0) match = 1;
165:         } else {
166:             if (entry->key == key) match = 1;
167:         }
168:         if (match) {
169:             entry->value = value;
170:             return map;
171:         }
172:         entry = entry->next;
173:     }
174:     MapEntry* new_entry = onu_malloc(sizeof(MapEntry));
175:     new_entry->key = key;
176:     new_entry->value = value;
177:     new_entry->hash = h;
178:     new_entry->next = map->buckets[idx];
179:     map->buckets[idx] = new_entry;
180:     map->size++;
181:     return map;
182: }
183: void* onu_map_find(Map* map, void* key, int is_string) {
184:     unsigned long long h = onu_hash(key, is_string);
185:     long long idx = h % map->capacity;
186:     MapEntry* entry = map->buckets[idx];
187:     while (entry) {
188:         int match = 0;
189:         if (is_string) {
190:             String* s1 = (String*)key;
191:             String* s2 = (String*)entry->key;
192:             if (s1->len == s2->len && memcmp(s1->data, s2->data, s1->len) == 0) match = 1;
193:         } else {
194:             if (entry->key == key) match = 1;
195:         }
196:         if (match) return entry->value;
197:         entry = entry->next;
198:     }
199:     return NULL;
200: }
201: long long onu_max(long long a, long long b) { return a > b ? a : b; }
202: long long onu_get_height(TreeNode* n) { return n ? n->height : 0; }
203: TreeNode* onu_rotate_right(TreeNode* y) {
204:     TreeNode* x = y->left;
205:     TreeNode* T2 = x->right;
206:     x->right = y;
207:     y->left = T2;
208:     y->height = onu_max(onu_get_height(y->left), onu_get_height(y->right)) + 1;
209:     x->height = onu_max(onu_get_height(x->left), onu_get_height(x->right)) + 1;
210:     return x;
211: }
212: TreeNode* onu_rotate_left(TreeNode* x) {
213:     TreeNode* y = x->right;
214:     TreeNode* T2 = y->left;
215:     y->left = x;
216:     x->right = T2;
217:     x->height = onu_max(onu_get_height(x->left), onu_get_height(x->right)) + 1;
218:     y->height = onu_max(onu_get_height(y->left), onu_get_height(y->right)) + 1;
219:     return y;
220: }
221: TreeNode* onu_tree_insert_node(TreeNode* node, void* value) {
222:     if (node == NULL) {
223:         TreeNode* n = onu_malloc(sizeof(TreeNode));
224:         n->value = value;
225:         n->left = n->right = NULL;
226:         n->height = 1;
227:         return n;
228:     }
229:     if ((long long)value < (long long)node->value)
230:         node->left = onu_tree_insert_node(node->left, value);
231:     else if ((long long)value > (long long)node->value)
232:         node->right = onu_tree_insert_node(node->right, value);
233:     else
234:         return node;
235:     node->height = 1 + onu_max(onu_get_height(node->left), onu_get_height(node->right));
236:     long long balance = onu_get_height(node->left) - onu_get_height(node->right);
237:     if (balance > 1 && (long long)value < (long long)node->left->value)
238:         return onu_rotate_right(node);
239:     if (balance < -1 && (long long)value > (long long)node->right->value)
240:         return onu_rotate_left(node);
241:     if (balance > 1 && (long long)value > (long long)node->left->value) {
242:         node->left = onu_rotate_left(node->left);
243:         return onu_rotate_right(node);
244:     }
245:     if (balance < -1 && (long long)value < (long long)node->right->value) {
246:         node->right = onu_rotate_right(node->right);
247:         return onu_rotate_left(node);
248:     }
249:     return node;
250: }
251: Tree* onu_tree_create() {
252:     Tree* tree = onu_malloc(sizeof(Tree));
253:     tree->root = NULL;
254:     tree->size = 0;
255:     return tree;
256: }
257: Tree* onu_tree_insert(Tree* tree, void* value) {
258:     tree->root = onu_tree_insert_node(tree->root, value);
259:     tree->size++;
260:     return tree;
261: }
262: static int global_argc = 0;
263: static char** global_argv = NULL;
264: void onu_init_args(int argc, char** argv) {
265:     global_argc = argc;
266:     global_argv = argv;
267: }
268: long long onu_get_arg_count() {
269:     return (long long)global_argc;
270: }
271: String onu_get_arg(long long index) {
272:     if (index < 0 || index >= global_argc) {
273:         String empty = {0, ""};
274:         return empty;
275:     }
276:     return onu_create_string(global_argv[index]);
277: }
278: String onu_receives_line() __asm__("receives-line");
279: long long onu_as_integer(String s) __asm__("as-integer");
280: long long onu_receives_entropy() __asm__("receives-entropy");
281: String onu_receives_line() {
282:     char buf[1024];
283:     if (fgets(buf, sizeof(buf), stdin)) {
284:         size_t len = strlen(buf);
285:         if (len > 0 && buf[len-1] == '\n') {
286:             buf[len-1] = '\0';
287:             len--;
288:         }
289:         return onu_create_string(buf);
290:     }
291:     return onu_create_string("");
292: }
293: long long onu_as_integer(String s) {
294:     return atoll(s.data);
295: }
296: #include <time.h>
297: long long onu_receives_entropy() {
298:     static int initialized = 0;
299:     if (!initialized) {
300:         srand(time(NULL));
301:         initialized = 1;
302:     }
303:     return (long long)rand();
304: }
305: #include <unistd.h>
306: void onu_sleep(long long ms) {
307:     usleep(ms * 1000);
308: }
309: void broadcasts(const char* s) {
310:     if (s != NULL) {
311:         puts(s);
312:         fflush(stdout);
313:     }
314: }
</file>

<file path="sample.ll">
 1: ; ModuleID = 'onu_discourse'
 2: source_filename = "onu_discourse"
 3: 
 4: define i64 @example_derivation(i64 %0) {
 5: entry:
 6:   %v1 = alloca i64, align 8
 7:   %x = alloca i64, align 8
 8:   store i64 %0, i64* %x, align 4
 9:   br label %bb0
10: 
11: bb0:                                              ; preds = %entry
12:   store i64 10, i64* %v1, align 4
13:   %v11 = load i64, i64* %v1, align 4
14:   ret i64 %v11
15: }
16: 
17: define i32 @main(i32 %0, i8** %1) {
18: entry:
19:   %v3 = alloca i64, align 8
20:   %v2 = alloca i64, align 8
21:   %__argc = alloca i32, align 4
22:   store i32 %0, i32* %__argc, align 4
23:   %__argv = alloca i8**, align 8
24:   store i8** %1, i8*** %__argv, align 8
25:   br label %bb0
26: 
27: bb0:                                              ; preds = %entry
28:   %calltmp = call i64 @example_derivation(i64 5)
29:   store i64 %calltmp, i64* %v2, align 4
30:   %v21 = load i64, i64* %v2, align 4
31:   store i64 %v21, i64* %v3, align 4
32:   %v32 = load i64, i64* %v3, align 4
33:   %ptr_cast = inttoptr i64 %v32 to i8*
34:   call void @broadcasts(i8* %ptr_cast)
35:   ret i32 0
36: }
37: 
38: declare void @broadcasts(i8*)
</file>

<file path="test.onu">
1: the-module-called Greeting the-behavior-called main "Hello Clean Architecture"
</file>

<file path="src/adapters/codegen/mod.rs">
  1: pub mod strategies;
  2: use crate::application::ports::compiler_ports::CodegenPort;
  3: use crate::application::use_cases::registry_service::RegistryService;
  4: use crate::domain::entities::error::OnuError;
  5: use crate::domain::entities::mir::{MirProgram, MirFunction, MirInstruction, MirTerminator};
  6: use crate::domain::entities::types::OnuType;
  7: use crate::adapters::codegen::strategies::*;
  8: use crate::application::options::LogLevel;
  9: use inkwell::context::Context;
 10: use inkwell::builder::Builder;
 11: use inkwell::module::Module;
 12: use inkwell::values::{FunctionValue, PointerValue};
 13: use inkwell::types::{BasicTypeEnum, BasicMetadataTypeEnum, BasicType};
 14: use std::collections::HashMap;
 15: use chrono::Local;
 16: pub struct OnuCodegen {
 17:     registry: Option<RegistryService>,
 18:     pub log_level: LogLevel,
 19: }
 20: impl OnuCodegen {
 21:     pub fn new(log_level: LogLevel) -> Self {
 22:         Self { registry: None, log_level }
 23:     }
 24:     fn log(&self, level: LogLevel, message: &str) {
 25:         if level <= self.log_level && level != LogLevel::None {
 26:             let timestamp = Local::now().to_rfc3339();
 27:             eprintln!("[{}] {:?}: [Codegen] {}", timestamp, level, message);
 28:         }
 29:     }
 30: }
 31: impl CodegenPort for OnuCodegen {
 32:     fn set_registry(&mut self, registry: RegistryService) {
 33:         self.registry = Some(registry);
 34:     }
 35:     fn generate(&self, program: &MirProgram) -> Result<String, OnuError> {
 36:         self.log(LogLevel::Info, "Starting LLVM IR generation");
 37:         let context = Context::create();
 38:         let module = context.create_module("onu_discourse");
 39:         let builder = context.create_builder();
 40:         let mut generator = LlvmGenerator {
 41:             context: &context,
 42:             module,
 43:             builder,
 44:             registry: self.registry.as_ref().expect("Registry not provided to codegen"),
 45:             ssa_storage: HashMap::new(),
 46:             blocks: HashMap::new(),
 47:             log_level: self.log_level,
 48:         };
 49:         generator.generate(program)?;
 50:         self.log(LogLevel::Info, "LLVM IR generation successful");
 51:         Ok(generator.module.print_to_string().to_string())
 52:     }
 53: }
 54: struct LlvmGenerator<'a, 'ctx> {
 55:     context: &'ctx Context,
 56:     module: Module<'ctx>,
 57:     builder: Builder<'ctx>,
 58:     registry: &'a RegistryService,
 59:     ssa_storage: HashMap<usize, PointerValue<'ctx>>,
 60:     blocks: HashMap<usize, inkwell::basic_block::BasicBlock<'ctx>>,
 61:     log_level: LogLevel,
 62: }
 63: impl<'a, 'ctx> LlvmGenerator<'a, 'ctx> {
 64:     fn log(&self, level: LogLevel, message: &str) {
 65:         if level <= self.log_level && level != LogLevel::None {
 66:             let timestamp = Local::now().to_rfc3339();
 67:             eprintln!("[{}] {:?}: [LlvmGenerator] {}", timestamp, level, message);
 68:         }
 69:     }
 70:     fn generate(&mut self, program: &MirProgram) -> Result<(), OnuError> {
 71:         self.log(LogLevel::Debug, "Declaring all functions");
 72:         for func in &program.functions {
 73:             self.declare_function(func)?;
 74:         }
 75:         self.log(LogLevel::Debug, "Generating all function bodies");
 76:         for func in &program.functions {
 77:             self.generate_function(func)?;
 78:         }
 79:         Ok(())
 80:     }
 81:     fn declare_function(&mut self, func: &MirFunction) -> Result<FunctionValue<'ctx>, OnuError> {
 82:         let llvm_name = if func.name == "run" || func.name == "main" { "main".to_string() } else { func.name.replace('-', "_") };
 83:         self.log(LogLevel::Trace, &format!("Declaring function: {} -> {}", func.name, llvm_name));
 84:         let arg_types: Vec<BasicMetadataTypeEnum> = if llvm_name == "main" {
 85:             let i32_type = self.context.i32_type();
 86:             let char_ptr_ptr_type = self.context.i8_type().ptr_type(inkwell::AddressSpace::default()).ptr_type(inkwell::AddressSpace::default());
 87:             vec![i32_type.into(), char_ptr_ptr_type.into()]
 88:         } else {
 89:             func.args.iter()
 90:                 .map(|arg| self.onu_type_to_llvm(&arg.typ).unwrap().into())
 91:                 .collect()
 92:         };
 93:         let ret_type = if llvm_name == "main" {
 94:             self.context.i32_type().as_basic_type_enum()
 95:         } else {
 96:             self.onu_type_to_llvm(&func.return_type).unwrap_or(self.context.i64_type().as_basic_type_enum())
 97:         };
 98:         let fn_type = if llvm_name == "main" {
 99:             self.context.i32_type().fn_type(&arg_types, false)
100:         } else if func.return_type == OnuType::Nothing {
101:             self.context.void_type().fn_type(&arg_types, false)
102:         } else {
103:             ret_type.fn_type(&arg_types, false)
104:         };
105:         Ok(self.module.add_function(&llvm_name, fn_type, None))
106:     }
107:     fn generate_function(&mut self, func: &MirFunction) -> Result<(), OnuError> {
108:         let llvm_name = if func.name == "run" || func.name == "main" { "main".to_string() } else { func.name.replace('-', "_") };
109:         self.log(LogLevel::Debug, &format!("Generating body for function: {}", llvm_name));
110:         let function = self.module.get_function(&llvm_name).unwrap();
111:         let entry_bb = self.context.append_basic_block(function, "entry");
112:         self.builder.position_at_end(entry_bb);
113:         self.ssa_storage.clear();
114:         self.blocks.clear();
115:         // Allocate storage for arguments and store them
116:         for (i, arg) in function.get_param_iter().enumerate() {
117:             let mir_arg = &func.args[i];
118:             let ptr = self.builder.build_alloca(arg.get_type(), &mir_arg.name).unwrap();
119:             self.builder.build_store(ptr, arg).unwrap();
120:             self.ssa_storage.insert(mir_arg.ssa_var, ptr);
121:         }
122:         // Create basic blocks
123:         for block in &func.blocks {
124:             let llvm_block = self.context.append_basic_block(function, &format!("bb{}", block.id));
125:             self.blocks.insert(block.id, llvm_block);
126:         }
127:         // Branch to first block
128:         if let Some(first_block) = func.blocks.first() {
129:             let target = self.blocks.get(&first_block.id).unwrap();
130:             self.builder.build_unconditional_branch(*target).unwrap();
131:         }
132:         // Generate instructions for each block
133:         for block in &func.blocks {
134:             let llvm_block = self.blocks.get(&block.id).unwrap();
135:             self.builder.position_at_end(*llvm_block);
136:             for inst in &block.instructions {
137:                 self.generate_instruction(inst)?;
138:             }
139:             self.generate_terminator(&block.terminator, &func.return_type, llvm_name == "main")?;
140:         }
141:         Ok(())
142:     }
143:     fn generate_instruction(&mut self, inst: &MirInstruction) -> Result<(), OnuError> {
144:         match inst {
145:             MirInstruction::BinaryOperation { .. } => {
146:                 BinaryOpStrategy.generate(self.context, &self.module, &self.builder, self.registry, &mut self.ssa_storage, inst, self.log_level)
147:             }
148:             MirInstruction::Call { .. } => {
149:                 CallStrategy.generate(self.context, &self.module, &self.builder, self.registry, &mut self.ssa_storage, inst, self.log_level)
150:             }
151:             MirInstruction::Emit(..) => {
152:                 EmitStrategy.generate(self.context, &self.module, &self.builder, self.registry, &mut self.ssa_storage, inst, self.log_level)
153:             }
154:             MirInstruction::Assign { .. } => {
155:                 AssignStrategy.generate(self.context, &self.module, &self.builder, self.registry, &mut self.ssa_storage, inst, self.log_level)
156:             }
157:             MirInstruction::Drop { .. } => {
158:                 DropStrategy.generate(self.context, &self.module, &self.builder, self.registry, &mut self.ssa_storage, inst, self.log_level)
159:             }
160:             MirInstruction::Index { .. } => {
161:                 IndexStrategy.generate(self.context, &self.module, &self.builder, self.registry, &mut self.ssa_storage, inst, self.log_level)
162:             }
163:             _ => Ok(()),
164:         }
165:     }
166:     fn generate_terminator(&mut self, term: &MirTerminator, ret_onu_type: &OnuType, is_main: bool) -> Result<(), OnuError> {
167:         match term {
168:             MirTerminator::Return(op) => {
169:                 if is_main {
170:                     self.builder.build_return(Some(&self.context.i32_type().const_int(0, false))).unwrap();
171:                 } else if *ret_onu_type == OnuType::Nothing {
172:                     self.builder.build_return(None).unwrap();
173:                 } else {
174:                     let val = strategies::operand_to_llvm(self.context, &self.builder, &mut self.ssa_storage, op, self.log_level);
175:                     self.builder.build_return(Some(&val)).unwrap();
176:                 }
177:             }
178:             MirTerminator::Branch(target) => {
179:                 let target_bb = self.blocks.get(target).unwrap();
180:                 self.builder.build_unconditional_branch(*target_bb).unwrap();
181:             }
182:             MirTerminator::CondBranch { condition, then_block, else_block } => {
183:                 let cond_val = strategies::operand_to_llvm(self.context, &self.builder, &mut self.ssa_storage, condition, self.log_level);
184:                 let cond = if cond_val.get_type() == self.context.bool_type().as_basic_type_enum() {
185:                     cond_val.into_int_value()
186:                 } else {
187:                     self.builder.build_int_compare(inkwell::IntPredicate::NE, cond_val.into_int_value(), self.context.i64_type().const_int(0, false), "bool_cast").unwrap()
188:                 };
189:                 let then_bb = self.blocks.get(then_block).unwrap();
190:                 let else_bb = self.blocks.get(else_block).unwrap();
191:                 self.builder.build_conditional_branch(cond, *then_bb, *else_bb).unwrap();
192:             }
193:             MirTerminator::Unreachable => {
194:                 self.builder.build_unreachable().unwrap();
195:             }
196:         }
197:         Ok(())
198:     }
199:     fn onu_type_to_llvm(&self, typ: &OnuType) -> Option<BasicTypeEnum<'ctx>> {
200:         match typ {
201:             OnuType::I32 => Some(self.context.i32_type().as_basic_type_enum()),
202:             OnuType::I64 => Some(self.context.i64_type().as_basic_type_enum()),
203:             OnuType::Boolean => Some(self.context.bool_type().as_basic_type_enum()),
204:             OnuType::Strings => {
205:                 let i64_type = self.context.i64_type();
206:                 let i8_ptr_type = self.context.i8_type().ptr_type(inkwell::AddressSpace::default());
207:                 Some(self.context.struct_type(&[i64_type.into(), i8_ptr_type.into()], false).as_basic_type_enum())
208:             }
209:             OnuType::Nothing => Some(self.context.i64_type().as_basic_type_enum()),
210:             _ => Some(self.context.i64_type().as_basic_type_enum()),
211:         }
212:     }
213: }
</file>

<file path="src/adapters/codegen/strategies.rs">
  1: use crate::domain::entities::mir::{MirInstruction, MirOperand, MirLiteral, MirBinOp};
  2: use crate::domain::entities::error::OnuError;
  3: use crate::application::use_cases::registry_service::RegistryService;
  4: use crate::application::options::LogLevel;
  5: use inkwell::context::Context;
  6: use inkwell::builder::Builder;
  7: use inkwell::module::Module;
  8: use inkwell::values::{PointerValue, BasicValueEnum, BasicValue};
  9: use inkwell::types::{BasicTypeEnum, BasicType};
 10: use std::collections::HashMap;
 11: use chrono::Local;
 12: pub trait InstructionStrategy<'ctx> {
 13:     fn generate(
 14:         &self,
 15:         context: &'ctx Context,
 16:         module: &Module<'ctx>,
 17:         builder: &Builder<'ctx>,
 18:         registry: &RegistryService,
 19:         ssa_storage: &mut HashMap<usize, PointerValue<'ctx>>,
 20:         inst: &MirInstruction,
 21:         log_level: LogLevel,
 22:     ) -> Result<(), OnuError>;
 23: }
 24: fn log(level: LogLevel, current_level: LogLevel, message: &str) {
 25:     if level <= current_level && level != LogLevel::None {
 26:         let timestamp = Local::now().to_rfc3339();
 27:         eprintln!("[{}] {:?}: [CodegenStrategy] {}", timestamp, level, message);
 28:     }
 29: }
 30: pub struct BinaryOpStrategy;
 31: impl<'ctx> InstructionStrategy<'ctx> for BinaryOpStrategy {
 32:     fn generate(
 33:         &self,
 34:         context: &'ctx Context,
 35:         _module: &Module<'ctx>,
 36:         builder: &Builder<'ctx>,
 37:         _registry: &RegistryService,
 38:         ssa_storage: &mut HashMap<usize, PointerValue<'ctx>>,
 39:         inst: &MirInstruction,
 40:         log_level: LogLevel,
 41:     ) -> Result<(), OnuError> {
 42:         if let MirInstruction::BinaryOperation { dest, op, lhs, rhs } = inst {
 43:             log(LogLevel::Trace, log_level, &format!("Generating BinOp: {:?} {:?} {:?}", lhs, op, rhs));
 44:             let l_val = operand_to_llvm(context, builder, ssa_storage, lhs, log_level);
 45:             let r_val = operand_to_llvm(context, builder, ssa_storage, rhs, log_level);
 46:             let res = match op {
 47:                 MirBinOp::Add => builder.build_int_add(l_val.into_int_value(), r_val.into_int_value(), "addtmp").unwrap().as_basic_value_enum(),
 48:                 MirBinOp::Sub => builder.build_int_sub(l_val.into_int_value(), r_val.into_int_value(), "subtmp").unwrap().as_basic_value_enum(),
 49:                 MirBinOp::Mul => builder.build_int_mul(l_val.into_int_value(), r_val.into_int_value(), "multmp").unwrap().as_basic_value_enum(),
 50:                 MirBinOp::Div => builder.build_int_signed_div(l_val.into_int_value(), r_val.into_int_value(), "divtmp").unwrap().as_basic_value_enum(),
 51:                 MirBinOp::Eq | MirBinOp::Gt | MirBinOp::Lt => {
 52:                     let pred = match op {
 53:                         MirBinOp::Eq => inkwell::IntPredicate::EQ,
 54:                         MirBinOp::Gt => inkwell::IntPredicate::SGT,
 55:                         MirBinOp::Lt => inkwell::IntPredicate::SLT,
 56:                         _ => unreachable!(),
 57:                     };
 58:                     let cond = builder.build_int_compare(pred, l_val.into_int_value(), r_val.into_int_value(), "cmptmp").unwrap();
 59:                     builder.build_int_z_extend(cond, context.i64_type(), "booltmp").unwrap().as_basic_value_enum()
 60:                 }
 61:             };
 62:             let ptr = get_or_create_ssa(context, builder, ssa_storage, *dest, res.get_type());
 63:             builder.build_store(ptr, res).unwrap();
 64:         }
 65:         Ok(())
 66:     }
 67: }
 68: pub struct CallStrategy;
 69: impl<'ctx> InstructionStrategy<'ctx> for CallStrategy {
 70:     fn generate(
 71:         &self,
 72:         context: &'ctx Context,
 73:         module: &Module<'ctx>,
 74:         builder: &Builder<'ctx>,
 75:         _registry: &RegistryService,
 76:         ssa_storage: &mut HashMap<usize, PointerValue<'ctx>>,
 77:         inst: &MirInstruction,
 78:         log_level: LogLevel,
 79:     ) -> Result<(), OnuError> {
 80:         if let MirInstruction::Call { dest, name, args } = inst {
 81:             let underscored = name.replace('-', "_");
 82:             let hyphenated = name.replace('_', "-");
 83:             let func = if let Some(f) = module.get_function(&underscored) {
 84:                 f
 85:             } else if let Some(f) = module.get_function(&hyphenated) {
 86:                 f
 87:             } else {
 88:                 log(LogLevel::Debug, log_level, &format!("Implicitly declaring external function: {}", hyphenated));
 89:                 let i64_type = context.i64_type();
 90:                 let mut arg_types = Vec::new();
 91:                 for _ in 0..args.len() { arg_types.push(i64_type.into()); }
 92:                 let ret_type = if ["as-text", "joined-with", "char-from-code", "tail-of", "init-of", "duplicated-as", "receives-argument", "receives-line"].contains(&hyphenated.as_str()) {
 93:                     let i8_ptr_type = context.i8_type().ptr_type(inkwell::AddressSpace::default());
 94:                     context.struct_type(&[i64_type.into(), i8_ptr_type.into()], false).as_basic_type_enum()
 95:                 } else {
 96:                     i64_type.as_basic_type_enum()
 97:                 };
 98:                 let fn_type = ret_type.fn_type(&arg_types, false);
 99:                 module.add_function(&hyphenated, fn_type, Some(inkwell::module::Linkage::External))
100:             };
101:             let mut llvm_args = Vec::new();
102:             for arg in args {
103:                 let val = operand_to_llvm(context, builder, ssa_storage, arg, log_level);
104:                 log(LogLevel::Trace, log_level, &format!("Arg type for {}: {:?}", name, val.get_type()));
105:                 llvm_args.push(val.into());
106:             }
107:             let call = builder.build_call(func, &llvm_args, "calltmp").unwrap();
108:             let res = match call.try_as_basic_value() {
109:                 inkwell::values::ValueKind::Basic(val) => val,
110:                 _ => context.i64_type().const_int(0, false).as_basic_value_enum(),
111:             };
112:             let ptr = get_or_create_ssa(context, builder, ssa_storage, *dest, res.get_type());
113:             builder.build_store(ptr, res).unwrap();
114:         }
115:         Ok(())
116:     }
117: }
118: pub struct EmitStrategy;
119: impl<'ctx> InstructionStrategy<'ctx> for EmitStrategy {
120:     fn generate(
121:         &self,
122:         context: &'ctx Context,
123:         module: &Module<'ctx>,
124:         builder: &Builder<'ctx>,
125:         _registry: &RegistryService,
126:         ssa_storage: &mut HashMap<usize, PointerValue<'ctx>>,
127:         inst: &MirInstruction,
128:         log_level: LogLevel,
129:     ) -> Result<(), OnuError> {
130:         if let MirInstruction::Emit(op) = inst {
131:             log(LogLevel::Trace, log_level, "Generating Emit");
132:             let str_ptr_type = context.i8_type().ptr_type(inkwell::AddressSpace::default());
133:             let fn_type = context.void_type().fn_type(&[str_ptr_type.into()], false);
134:             let broadcasts_fn = module.get_function("broadcasts").unwrap_or_else(|| {
135:                 module.add_function("broadcasts", fn_type, Some(inkwell::module::Linkage::External))
136:             });
137:             let val = operand_to_llvm(context, builder, ssa_storage, op, log_level);
138:             let arg = if val.is_struct_value() {
139:                 builder.build_extract_value(val.into_struct_value(), 1, "raw_ptr").unwrap()
140:             } else if val.is_int_value() {
141:                 builder.build_int_to_ptr(val.into_int_value(), str_ptr_type, "ptr_cast").unwrap().as_basic_value_enum()
142:             } else {
143:                 val
144:             };
145:             builder.build_call(broadcasts_fn, &[arg.into()], "emit").unwrap();
146:         }
147:         Ok(())
148:     }
149: }
150: pub struct AssignStrategy;
151: impl<'ctx> InstructionStrategy<'ctx> for AssignStrategy {
152:     fn generate(
153:         &self,
154:         context: &'ctx Context,
155:         _module: &Module<'ctx>,
156:         builder: &Builder<'ctx>,
157:         _registry: &RegistryService,
158:         ssa_storage: &mut HashMap<usize, PointerValue<'ctx>>,
159:         inst: &MirInstruction,
160:         log_level: LogLevel,
161:     ) -> Result<(), OnuError> {
162:         if let MirInstruction::Assign { dest, src } = inst {
163:             log(LogLevel::Trace, log_level, &format!("Generating Assign to SSA {}", dest));
164:             let val = operand_to_llvm(context, builder, ssa_storage, src, log_level);
165:             let ptr = get_or_create_ssa(context, builder, ssa_storage, *dest, val.get_type());
166:             builder.build_store(ptr, val).unwrap();
167:         }
168:         Ok(())
169:     }
170: }
171: pub struct DropStrategy;
172: impl<'ctx> InstructionStrategy<'ctx> for DropStrategy {
173:     fn generate(
174:         &self,
175:         _context: &'ctx Context,
176:         _module: &Module<'ctx>,
177:         _builder: &Builder<'ctx>,
178:         _registry: &RegistryService,
179:         _ssa_storage: &mut HashMap<usize, PointerValue<'ctx>>,
180:         _inst: &MirInstruction,
181:         log_level: LogLevel,
182:     ) -> Result<(), OnuError> {
183:         log(LogLevel::Trace, log_level, "Generating Drop (No-op)");
184:         Ok(())
185:     }
186: }
187: pub struct IndexStrategy;
188: impl<'ctx> InstructionStrategy<'ctx> for IndexStrategy {
189:     fn generate(
190:         &self,
191:         context: &'ctx Context,
192:         _module: &Module<'ctx>,
193:         builder: &Builder<'ctx>,
194:         _registry: &RegistryService,
195:         ssa_storage: &mut HashMap<usize, PointerValue<'ctx>>,
196:         inst: &MirInstruction,
197:         log_level: LogLevel,
198:     ) -> Result<(), OnuError> {
199:         if let MirInstruction::Index { dest, subject, index } = inst {
200:             log(LogLevel::Trace, log_level, &format!("Generating Index {} on subject", index));
201:             let val = operand_to_llvm(context, builder, ssa_storage, subject, log_level);
202:             if let BasicValueEnum::StructValue(s) = val {
203:                 let elem = builder.build_extract_value(s, *index as u32, "index_tmp").unwrap();
204:                 let ptr = get_or_create_ssa(context, builder, ssa_storage, *dest, elem.get_type());
205:                 builder.build_store(ptr, elem).unwrap();
206:             }
207:         }
208:         Ok(())
209:     }
210: }
211: pub fn operand_to_llvm<'ctx>(
212:     context: &'ctx Context,
213:     builder: &Builder<'ctx>,
214:     ssa_storage: &HashMap<usize, PointerValue<'ctx>>,
215:     op: &MirOperand,
216:     _log_level: LogLevel,
217: ) -> BasicValueEnum<'ctx> {
218:     match op {
219:         MirOperand::Constant(lit) => match lit {
220:             MirLiteral::I64(n) => context.i64_type().const_int(*n as u64, true).as_basic_value_enum(),
221:             MirLiteral::F64(bits) => context.f64_type().const_float(f64::from_bits(*bits)).as_basic_value_enum(),
222:             MirLiteral::Boolean(b) => context.bool_type().const_int(if *b { 1 } else { 0 }, false).as_basic_value_enum(),
223:             MirLiteral::Text(s) => {
224:                 let length = context.i64_type().const_int(s.len() as u64, false);
225:                 let global_str = builder.build_global_string_ptr(s, "strtmp").unwrap();
226:                 let i64_type = context.i64_type();
227:                 let i8_ptr_type = context.i8_type().ptr_type(inkwell::AddressSpace::default());
228:                 let string_struct_type = context.struct_type(&[i64_type.into(), i8_ptr_type.into()], false);
229:                 let mut string_val = string_struct_type.get_undef();
230:                 string_val = builder.build_insert_value(string_val, length, 0, "set_len").unwrap().into_struct_value();
231:                 string_val = builder.build_insert_value(string_val, global_str, 1, "set_ptr").unwrap().into_struct_value();
232:                 string_val.as_basic_value_enum()
233:             }
234:             MirLiteral::Nothing => context.i64_type().const_int(0, false).as_basic_value_enum(),
235:         },
236:         MirOperand::Variable(id, _) => {
237:             let ptr = ssa_storage.get(id).expect(&format!("SSA variable {} not found", id));
238:             builder.build_load(*ptr, &format!("v{}", id)).unwrap()
239:         }
240:     }
241: }
242: pub fn get_or_create_ssa<'ctx>(
243:     context: &'ctx Context,
244:     builder: &Builder<'ctx>,
245:     ssa_storage: &mut HashMap<usize, PointerValue<'ctx>>,
246:     id: usize,
247:     typ: BasicTypeEnum<'ctx>,
248: ) -> PointerValue<'ctx> {
249:     if let Some(ptr) = ssa_storage.get(&id) {
250:         return *ptr;
251:     }
252:     let current_bb = builder.get_insert_block().unwrap();
253:     let function = current_bb.get_parent().unwrap();
254:     let entry_bb = function.get_first_basic_block().unwrap();
255:     let temp_builder = context.create_builder();
256:     if let Some(first_inst) = entry_bb.get_first_instruction() {
257:         temp_builder.position_before(&first_inst);
258:     } else {
259:         temp_builder.position_at_end(entry_bb);
260:     }
261:     let ptr = temp_builder.build_alloca(typ, &format!("v{}", id)).unwrap();
262:     ssa_storage.insert(id, ptr);
263:     ptr
264: }
</file>

<file path="src/adapters/lexer/mod.rs">
  1: use crate::application::ports::compiler_ports::{LexerPort, Token, Literal};
  2: use crate::application::options::LogLevel;
  3: use crate::domain::entities::error::OnuError;
  4: use std::iter::Peekable;
  5: use std::str::Chars;
  6: use chrono::Local;
  7: pub struct OnuLexer {
  8:     pub log_level: LogLevel,
  9: }
 10: impl OnuLexer {
 11:     pub fn new(log_level: LogLevel) -> Self {
 12:         Self { log_level }
 13:     }
 14:     fn log(&self, level: LogLevel, message: &str) {
 15:         if level <= self.log_level && level != LogLevel::None {
 16:             let timestamp = Local::now().to_rfc3339();
 17:             eprintln!("[{}] {:?}: [Lexer] {}", timestamp, level, message);
 18:         }
 19:     }
 20: }
 21: impl LexerPort for OnuLexer {
 22:     fn lex(&self, source: &str) -> Result<Vec<Token>, OnuError> {
 23:         self.log(LogLevel::Info, "Starting lexing process");
 24:         let mut lexer = LexerInternal::new(source, self.log_level);
 25:         let mut tokens = Vec::new();
 26:         while let Some(token_result) = lexer.next_token() {
 27:             let token = token_result?;
 28:             self.log(LogLevel::Trace, &format!("Lexed token: {:?}", token));
 29:             tokens.push(token);
 30:         }
 31:         self.log(LogLevel::Info, &format!("Lexing successful: {} tokens", tokens.len()));
 32:         Ok(tokens)
 33:     }
 34: }
 35: struct LexerInternal<'a> {
 36:     input: Peekable<Chars<'a>>,
 37:     at_line_start: bool,
 38:     log_level: LogLevel,
 39: }
 40: impl<'a> LexerInternal<'a> {
 41:     fn new(input: &'a str, log_level: LogLevel) -> Self {
 42:         Self {
 43:             input: input.chars().peekable(),
 44:             at_line_start: true,
 45:             log_level,
 46:         }
 47:     }
 48:     fn log(&self, level: LogLevel, message: &str) {
 49:         if level <= self.log_level && level != LogLevel::None {
 50:             let timestamp = Local::now().to_rfc3339();
 51:             eprintln!("[{}] {:?}: [LexerInternal] {}", timestamp, level, message);
 52:         }
 53:     }
 54:     fn peek_char(&mut self) -> Option<char> {
 55:         self.input.peek().copied()
 56:     }
 57:     fn skip_whitespace_except_newline(&mut self) {
 58:         while let Some(c) = self.peek_char() {
 59:             if c.is_whitespace() && c != '\n' {
 60:                 self.input.next();
 61:             } else {
 62:                 break;
 63:             }
 64:         }
 65:     }
 66:     fn skip_comment(&mut self) {
 67:         self.log(LogLevel::Trace, "Skipping comment");
 68:         self.input.next();
 69:         while let Some(c) = self.input.next() {
 70:             if c == '\n' {
 71:                 self.at_line_start = true;
 72:                 break;
 73:             }
 74:         }
 75:     }
 76:     fn next_token(&mut self) -> Option<Result<Token, OnuError>> {
 77:         if self.at_line_start {
 78:             self.at_line_start = false;
 79:             let mut indent = 0;
 80:             while let Some(c) = self.peek_char() {
 81:                 if c == ' ' {
 82:                     indent += 1;
 83:                     self.input.next();
 84:                 } else if c == '\t' {
 85:                     indent += 4;
 86:                     self.input.next();
 87:                 } else if c == '\n' {
 88:                     self.input.next();
 89:                     self.at_line_start = true;
 90:                     indent = 0;
 91:                 } else if c == '-' {
 92:                     let mut temp = self.input.clone();
 93:                     temp.next();
 94:                     if let Some('-') = temp.peek() {
 95:                         self.skip_comment();
 96:                         return self.next_token();
 97:                     } else { break; }
 98:                 } else if c.is_whitespace() {
 99:                     self.input.next();
100:                 } else { break; }
101:             }
102:             if self.peek_char().is_some() {
103:                 return Some(Ok(Token::LineStart(indent)));
104:             } else {
105:                 return None;
106:             }
107:         }
108:         self.skip_whitespace_except_newline();
109:         let first_char = self.peek_char()?;
110:         if first_char == '\n' {
111:             self.input.next();
112:             self.at_line_start = true;
113:             return self.next_token();
114:         }
115:         if first_char == '-' {
116:             let mut temp = self.input.clone();
117:             temp.next();
118:             if let Some('-') = temp.peek() {
119:                 self.skip_comment();
120:                 return self.next_token();
121:             }
122:         }
123:         let token = match first_char {
124:             '(' => { self.input.next(); Token::Delimiter('(') }
125:             ')' => { self.input.next(); Token::Delimiter(')') }
126:             ':' => { self.input.next(); Token::Operator(":".to_string()) }
127:             '"' => self.lex_string(),
128:             c if c.is_ascii_digit() => self.lex_number(),
129:             c if c.is_alphanumeric() || c == '-' => self.lex_complex_keyword_or_id(),
130:             _ => {
131:                 self.input.next();
132:                 return self.next_token();
133:             }
134:         };
135:         Some(Ok(token))
136:     }
137:     fn lex_string(&mut self) -> Token {
138:         self.input.next();
139:         let mut s = String::new();
140:         while let Some(c) = self.input.next() {
141:             if c == '"' { break; }
142:             s.push(c);
143:         }
144:         Token::Literal(Literal::String(s))
145:     }
146:     fn lex_number(&mut self) -> Token {
147:         let mut s = String::new();
148:         let mut is_float = false;
149:         while let Some(c) = self.peek_char() {
150:             if c.is_ascii_digit() {
151:                 s.push(c);
152:                 self.input.next();
153:             } else if c == '.' && !is_float {
154:                 is_float = true;
155:                 s.push(c);
156:                 self.input.next();
157:             } else { break; }
158:         }
159:         if is_float {
160:             Token::Literal(Literal::FloatBits(s.parse::<f64>().unwrap_or(0.0).to_bits()))
161:         } else {
162:             Token::Literal(Literal::Integer(s.parse::<i128>().unwrap_or(0)))
163:         }
164:     }
165:     fn lex_complex_keyword_or_id(&mut self) -> Token {
166:         let phrases = [
167:             ("the-module-called", Token::TheModuleCalled),
168:             ("the-behavior-called", Token::TheBehaviorCalled),
169:             ("the-effect-behavior-called", Token::TheEffectBehaviorCalled),
170:             ("with-intent", Token::WithIntent),
171:             ("with-concern", Token::WithConcern),
172:             ("with-diminishing", Token::WithDiminishing),
173:             ("no-guaranteed-termination", Token::NoGuaranteedTermination),
174:             ("derives-from", Token::DerivesFrom),
175:             ("decreased-by", Token::DecreasedBy),
176:             ("partitions-by", Token::PartitionsBy),
177:             ("scales-by", Token::ScalesBy),
178:             ("added-to", Token::AddedTo),
179:             ("utilizes", Token::Utilizes),
180:             ("broadcasts", Token::Broadcasts),
181:             ("derivation", Token::Derivation),
182:             ("matches", Token::Matches),
183:             ("exceeds", Token::Exceeds),
184:             ("falls-short-of", Token::FallsShortOf),
185:             ("unites-with", Token::UnitesWith),
186:             ("joins-with", Token::JoinsWith),
187:             ("opposes", Token::Opposes),
188:             ("init-of", Token::InitOf),
189:             ("tail-of", Token::TailOf),
190:         ];
191:         let mut current_pos = self.input.clone();
192:         let mut words = Vec::new();
193:         let mut matched_token = None;
194:         for _ in 0..4 {
195:             let mut word = String::new();
196:             while let Some(c) = current_pos.peek() {
197:                 if c.is_alphanumeric() || *c == '-' { word.push(*c); current_pos.next(); } else { break; }
198:             }
199:             if word.is_empty() { break; }
200:             words.push(word);
201:             let candidate = words.join("-");
202:             for (phrase, token) in &phrases {
203:                 if phrase == &candidate {
204:                     matched_token = Some(token.clone());
205:                     self.input = current_pos.clone();
206:                 }
207:             }
208:             while let Some(c) = current_pos.peek() {
209:                 if c.is_whitespace() && *c != '\n' { current_pos.next(); } else { break; }
210:             }
211:         }
212:         if let Some(t) = matched_token { return t; }
213:         let mut s = String::new();
214:         while let Some(c) = self.peek_char() {
215:             if c.is_alphanumeric() || c == '-' { s.push(c); self.input.next(); } else { break; }
216:         }
217:         match s.as_str() {
218:             "if" => Token::If,
219:             "then" => Token::Then,
220:             "else" => Token::Else,
221:             "takes" => Token::Takes,
222:             "delivers" => Token::Delivers,
223:             "called" => Token::Called,
224:             "as" => Token::As,
225:             "nothing" => Token::Nothing,
226:             "true" => Token::Literal(Literal::Boolean(true)),
227:             "false" => Token::Literal(Literal::Boolean(false)),
228:             _ => Token::Identifier(s),
229:         }
230:     }
231: }
</file>

<file path="src/adapters/parser/mod.rs">
  1: use crate::application::ports::compiler_ports::{ParserPort, Token, Literal};
  2: use crate::application::options::LogLevel;
  3: use crate::domain::entities::error::{OnuError, Span};
  4: use crate::domain::entities::ast::{Discourse, Expression, BehaviorHeader, ReturnType, Argument, TypeInfo};
  5: use crate::domain::entities::types::OnuType;
  6: use chrono::Local;
  7: pub struct OnuParser {
  8:     pub log_level: LogLevel,
  9: }
 10: impl OnuParser {
 11:     pub fn new(log_level: LogLevel) -> Self {
 12:         Self { log_level }
 13:     }
 14:     fn log(&self, level: LogLevel, message: &str) {
 15:         if level <= self.log_level && level != LogLevel::None {
 16:             let timestamp = Local::now().to_rfc3339();
 17:             eprintln!("[{}] {:?}: [Parser] {}", timestamp, level, message);
 18:         }
 19:     }
 20: }
 21: impl ParserPort for OnuParser {
 22:     fn parse(&self, tokens: Vec<Token>) -> Result<Vec<Discourse>, OnuError> {
 23:         self.log(LogLevel::Info, "Starting parsing process");
 24:         let mut parser = ParserInternal::new(tokens, self.log_level);
 25:         let mut discourses = Vec::new();
 26:         while !parser.is_at_end() {
 27:             if let Some(d) = parser.parse_discourse()? {
 28:                 self.log(LogLevel::Trace, &format!("Parsed discourse unit: {:?}", d));
 29:                 discourses.push(d);
 30:             } else {
 31:                 break;
 32:             }
 33:         }
 34:         self.log(LogLevel::Info, &format!("Parsing successful: {} discourse units", discourses.len()));
 35:         Ok(discourses)
 36:     }
 37: }
 38: struct ParserInternal {
 39:     tokens: Vec<Token>,
 40:     pos: usize,
 41:     log_level: LogLevel,
 42: }
 43: impl ParserInternal {
 44:     fn new(tokens: Vec<Token>, log_level: LogLevel) -> Self {
 45:         Self { tokens, pos: 0, log_level }
 46:     }
 47:     fn log(&self, level: LogLevel, message: &str) {
 48:         if level <= self.log_level && level != LogLevel::None {
 49:             let timestamp = Local::now().to_rfc3339();
 50:             eprintln!("[{}] {:?}: [ParserInternal] {}", timestamp, level, message);
 51:         }
 52:     }
 53:     fn is_at_end(&self) -> bool {
 54:         self.pos >= self.tokens.len()
 55:     }
 56:     fn peek(&self) -> Option<&Token> {
 57:         self.tokens.get(self.pos)
 58:     }
 59:     fn advance(&mut self) -> Option<&Token> {
 60:         if !self.is_at_end() {
 61:             self.pos += 1;
 62:             self.tokens.get(self.pos - 1)
 63:         } else {
 64:             None
 65:         }
 66:     }
 67:     fn consume(&mut self, expected: Token) -> Result<(), OnuError> {
 68:         self.skip_layout();
 69:         if let Some(t) = self.peek() {
 70:             if *t == expected {
 71:                 self.advance();
 72:                 return Ok(());
 73:             }
 74:             return Err(OnuError::GrammarViolation {
 75:                 message: format!("Expected {:?}, found {:?}", expected, t),
 76:                 span: Span::default()
 77:             });
 78:         }
 79:         Err(OnuError::GrammarViolation { message: format!("Expected {:?}, found EOF", expected), span: Span::default() })
 80:     }
 81:     fn match_token(&mut self, token: Token) -> bool {
 82:         if let Some(t) = self.peek() {
 83:             if *t == token {
 84:                 self.advance();
 85:                 return true;
 86:             }
 87:         }
 88:         false
 89:     }
 90:     fn skip_layout(&mut self) {
 91:         while let Some(t) = self.peek() {
 92:             if matches!(t, Token::Indent | Token::Dedent | Token::LineStart(_)) {
 93:                 self.advance();
 94:             } else {
 95:                 break;
 96:             }
 97:         }
 98:     }
 99:     fn parse_discourse(&mut self) -> Result<Option<Discourse>, OnuError> {
100:         while let Some(t) = self.peek() {
101:             match t {
102:                 Token::TheModuleCalled => return Ok(Some(self.parse_module()?)),
103:                 Token::TheBehaviorCalled | Token::TheEffectBehaviorCalled => return Ok(Some(self.parse_behavior()?)),
104:                 _ => {
105:                     self.advance();
106:                 }
107:             }
108:         }
109:         Ok(None)
110:     }
111:     fn parse_module(&mut self) -> Result<Discourse, OnuError> {
112:         self.log(LogLevel::Debug, "Parsing module");
113:         self.consume(Token::TheModuleCalled)?;
114:         self.skip_layout();
115:         let name = if let Some(Token::Identifier(n)) = self.advance() { n.clone() } else {
116:             return Err(OnuError::GrammarViolation { message: "Expected module name".into(), span: Span::default() });
117:         };
118:         self.consume(Token::WithConcern)?;
119:         self.match_token(Token::Operator(":".to_string()));
120:         let mut concern = String::new();
121:         while let Some(t) = self.peek() {
122:             if matches!(t, Token::TheModuleCalled | Token::TheBehaviorCalled | Token::TheEffectBehaviorCalled) { break; }
123:             if matches!(t, Token::Indent | Token::Dedent | Token::LineStart(_)) {
124:                 self.advance();
125:                 continue;
126:             }
127:             if !concern.is_empty() { concern.push(' '); }
128:             concern.push_str(&format!("{:?}", self.advance()).to_lowercase());
129:         }
130:         Ok(Discourse::Module { name, concern })
131:     }
132:     fn parse_behavior(&mut self) -> Result<Discourse, OnuError> {
133:         let is_effect = matches!(self.peek(), Some(Token::TheEffectBehaviorCalled));
134:         self.log(LogLevel::Debug, &format!("Parsing behavior (is_effect: {})", is_effect));
135:         self.advance();
136:         self.skip_layout();
137:         let name = if let Some(Token::Identifier(n)) = self.advance() { n.clone() } else {
138:             return Err(OnuError::GrammarViolation { message: "Expected behavior name".into(), span: Span::default() });
139:         };
140:         let mut takes = Vec::new();
141:         let mut delivers = ReturnType(OnuType::Nothing);
142:         while let Some(token) = self.peek() {
143:             match token {
144:                 Token::Takes => {
145:                     self.advance();
146:                     self.match_token(Token::Operator(":".to_string()));
147:                     takes = self.parse_arguments()?;
148:                 }
149:                 Token::Delivers => {
150:                     self.advance();
151:                     self.match_token(Token::Operator(":".to_string()));
152:                     delivers = self.parse_return_type()?;
153:                 }
154:                 Token::As => break,
155:                 Token::Indent | Token::Dedent | Token::LineStart(_) => { self.advance(); }
156:                 _ => { self.advance(); }
157:             }
158:         }
159:         self.consume(Token::As)?;
160:         self.skip_layout();
161:         self.match_token(Token::Operator(":".to_string()));
162:         let body = self.parse_block()?;
163:         Ok(Discourse::Behavior { header: BehaviorHeader { name, is_effect, intent: "Standard".to_string(), takes, delivers, diminishing: None, skip_termination_check: false }, body })
164:     }
165:     fn parse_block(&mut self) -> Result<Expression, OnuError> {
166:         let indented = self.match_token(Token::Indent);
167:         self.log(LogLevel::Trace, &format!("Parsing block (indented: {})", indented));
168:         let mut expressions = Vec::new();
169:         while !self.is_at_end() {
170:             if let Some(token) = self.peek() {
171:                 if matches!(token, Token::Dedent) {
172:                     if indented { self.advance(); }
173:                     break;
174:                 }
175:                 if matches!(token, Token::TheModuleCalled | Token::TheBehaviorCalled | Token::TheEffectBehaviorCalled) { break; }
176:             }
177:             let expr = self.parse_expression()?;
178:             if !matches!(expr, Expression::Nothing) {
179:                 expressions.push(expr);
180:             } else if !indented {
181:                 break;
182:             }
183:             if !indented { break; }
184:         }
185:         if expressions.len() == 1 {
186:             Ok(expressions.pop().unwrap())
187:         } else if expressions.is_empty() {
188:             Ok(Expression::Nothing)
189:         } else {
190:             Ok(Expression::Block(expressions))
191:         }
192:     }
193:     fn parse_arguments(&mut self) -> Result<Vec<Argument>, OnuError> {
194:         let mut args = Vec::new();
195:         while let Some(token) = self.peek() {
196:             match token {
197:                 Token::Delivers | Token::As | Token::Dedent => break,
198:                 Token::Identifier(_) | Token::Nothing => {
199:                     if self.match_token(Token::Nothing) { break; }
200:                     let type_info = self.parse_type_info()?.unwrap_or(TypeInfo { onu_type: OnuType::I64, display_name: "i64".into(), via_role: None, is_observation: false });
201:                     self.match_token(Token::Called);
202:                     self.skip_layout();
203:                     let name = if let Some(Token::Identifier(n)) = self.advance() { n.clone() } else { "".to_string() };
204:                     args.push(Argument { name, type_info });
205:                 }
206:                 Token::Indent | Token::LineStart(_) => { self.advance(); }
207:                 _ => { self.advance(); }
208:             }
209:         }
210:         Ok(args)
211:     }
212:     fn parse_type_info(&mut self) -> Result<Option<TypeInfo>, OnuError> {
213:         self.skip_layout();
214:         if let Some(Token::Identifier(s)) = self.peek() {
215:             if s == "a" || s == "an" || s == "the" {
216:                 self.advance();
217:                 self.skip_layout();
218:                 let type_name = if let Some(Token::Identifier(tn)) = self.advance() { tn.clone() } else { "i64".into() };
219:                 let onu_type = OnuType::from_name(&type_name).unwrap_or(OnuType::I64);
220:                 return Ok(Some(TypeInfo { onu_type, display_name: type_name, via_role: None, is_observation: false }));
221:             }
222:         }
223:         Ok(None)
224:     }
225:     fn parse_return_type(&mut self) -> Result<ReturnType, OnuError> {
226:         let ti = self.parse_type_info()?.map(|ti| ti.onu_type).unwrap_or(OnuType::Nothing);
227:         Ok(ReturnType(ti))
228:     }
229:     fn parse_expression(&mut self) -> Result<Expression, OnuError> {
230:         self.skip_layout();
231:         if self.match_token(Token::Broadcasts) {
232:             return Ok(Expression::Emit(Box::new(self.parse_expression()?)));
233:         }
234:         self.parse_infix(0)
235:     }
236:     fn parse_primary(&mut self) -> Result<Expression, OnuError> {
237:         self.skip_layout();
238:         if self.is_at_end() { return Ok(Expression::Nothing); }
239:         let token = self.peek().unwrap().clone();
240:         match token {
241:             Token::Literal(Literal::Integer(i)) => { self.advance(); Ok(Expression::I128(i)) },
242:             Token::Literal(Literal::FloatBits(f)) => { self.advance(); Ok(Expression::F64(f)) },
243:             Token::Literal(Literal::String(s)) => { self.advance(); Ok(Expression::Text(s)) },
244:             Token::Literal(Literal::Boolean(b)) => { self.advance(); Ok(Expression::Boolean(b)) },
245:             Token::If => self.parse_if(),
246:             Token::Derivation => self.parse_derivation(),
247:             Token::Identifier(s) => {
248:                 let name = s.clone();
249:                 self.advance();
250:                 Ok(Expression::Identifier(name))
251:             },
252:             Token::Nothing => { self.advance(); Ok(Expression::Nothing) },
253:             Token::Delimiter('(') => {
254:                 self.advance();
255:                 let inner = self.parse_expression()?;
256:                 self.consume(Token::Delimiter(')'))?;
257:                 Ok(inner)
258:             },
259:             Token::Indent => {
260:                 self.advance();
261:                 let res = self.parse_block()?;
262:                 self.match_token(Token::Dedent);
263:                 Ok(res)
264:             }
265:             _ => {
266:                 Ok(Expression::Nothing)
267:             }
268:         }
269:     }
270:     fn parse_infix(&mut self, min_precedence: u8) -> Result<Expression, OnuError> {
271:         let mut lhs = self.parse_primary()?;
272:         while let Some(token) = self.peek() {
273:             let (op_name, precedence) = match token {
274:                 Token::Matches => ("matches".into(), 2),
275:                 Token::Exceeds => ("exceeds".into(), 2),
276:                 Token::FallsShortOf => ("falls_short_of".into(), 2),
277:                 Token::AddedTo => ("added_to".into(), 3),
278:                 Token::DecreasedBy => ("decreased_by".into(), 3),
279:                 Token::ScalesBy => ("scales_by".into(), 4),
280:                 Token::PartitionsBy => ("partitions_by".into(), 4),
281:                 Token::UnitesWith => ("unites_with".into(), 4),
282:                 Token::JoinsWith => ("joins_with".into(), 4),
283:                 Token::Opposes => ("opposes".into(), 4),
284:                 Token::InitOf => ("init_of".into(), 4),
285:                 Token::TailOf => ("tail_of".into(), 4),
286:                 Token::Utilizes => ("utilizes".into(), 5),
287:                 _ => break,
288:             };
289:             if precedence < min_precedence { break; }
290:             self.advance();
291:             if op_name == "utilizes" {
292:                 if let Some(Token::Identifier(target)) = self.advance() {
293:                     lhs = Expression::BehaviorCall { name: target.clone(), args: vec![lhs] };
294:                 }
295:             } else {
296:                 let rhs = self.parse_infix(precedence + 1)?;
297:                 lhs = Expression::BehaviorCall { name: op_name, args: vec![lhs, rhs] };
298:             }
299:         }
300:         Ok(lhs)
301:     }
302:     fn parse_if(&mut self) -> Result<Expression, OnuError> {
303:         self.log(LogLevel::Trace, "Parsing if expression");
304:         self.consume(Token::If)?;
305:         let condition = self.parse_expression()?;
306:         self.skip_layout();
307:         self.consume(Token::Then)?;
308:         let then_branch = self.parse_expression()?;
309:         self.skip_layout();
310:         self.consume(Token::Else)?;
311:         let else_branch = self.parse_expression()?;
312:         Ok(Expression::If { condition: Box::new(condition), then_branch: Box::new(then_branch), else_branch: Box::new(else_branch) })
313:     }
314:     fn parse_derivation(&mut self) -> Result<Expression, OnuError> {
315:         self.log(LogLevel::Trace, "Parsing derivation");
316:         self.consume(Token::Derivation)?;
317:         self.match_token(Token::Operator(":".to_string()));
318:         self.skip_layout();
319:         let name = if let Some(Token::Identifier(n)) = self.advance() { n.clone() } else { "".into() };
320:         self.consume(Token::DerivesFrom)?;
321:         let _type_info = self.parse_type_info()?;
322:         let value = self.parse_expression()?;
323:         // Sibling expressions in a block become the "body" of the derivation
324:         let body = self.parse_expression()?;
325:         Ok(Expression::Derivation { name, type_info: None, value: Box::new(value), body: Box::new(body) })
326:     }
327: }
</file>

<file path="src/adapters/mod.rs">
1: pub mod lexer; pub mod parser; pub mod codegen;
</file>

<file path="src/application/ports/environment.rs">
1: use crate::domain::entities::error::OnuError;
2: use crate::application::options::LogLevel;
3: pub trait EnvironmentPort {
4:     fn read_file(&self, path: &str) -> Result<String, OnuError>;
5:     fn write_file(&self, path: &str, content: &str) -> Result<(), OnuError>;
6:     fn write_binary(&self, path: &str, content: &[u8]) -> Result<(), OnuError>;
7:     fn run_command(&self, command: &str, args: &[&str]) -> Result<String, OnuError>;
8:     fn log(&self, level: LogLevel, message: &str);
9: }
</file>

<file path="src/application/ports/mod.rs">
1: pub mod compiler_ports;
2: pub mod environment;
</file>

<file path="src/application/use_cases/analysis_service.rs">
 1: use crate::domain::entities::hir::HirDiscourse;
 2: use crate::domain::rules::liveness::LivenessRule;
 3: use crate::domain::rules::ownership::OwnershipRule;
 4: use crate::application::use_cases::registry_service::RegistryService;
 5: use crate::domain::entities::error::OnuError;
 6: use crate::application::options::LogLevel;
 7: use chrono::Local;
 8: pub struct AnalysisService<'a> {
 9:     registry: &'a RegistryService,
10:     liveness_rule: LivenessRule,
11:     ownership_rule: OwnershipRule<'a>,
12: }
13: impl<'a> AnalysisService<'a> {
14:     pub fn new(registry: &'a RegistryService) -> Self {
15:         Self {
16:             registry,
17:             liveness_rule: LivenessRule,
18:             ownership_rule: OwnershipRule { registry },
19:         }
20:     }
21:     fn log(&self, level: LogLevel, message: &str) {
22:         if level != LogLevel::None {
23:             let timestamp = Local::now().to_rfc3339();
24:             eprintln!("[{}] {:?}: [Analysis] {}", timestamp, level, message);
25:         }
26:     }
27:     pub fn analyze_discourse(&self, discourse: &mut HirDiscourse) -> Result<(), OnuError> {
28:         self.log(LogLevel::Debug, "Starting discourse analysis");
29:         match discourse {
30:             HirDiscourse::Behavior { header, body } => {
31:                 self.log(LogLevel::Trace, &format!("Analyzing behavior: {}", header.name));
32:                 self.liveness_rule.analyze(body);
33:                 self.ownership_rule.validate(header, body)?;
34:                 self.log(LogLevel::Trace, &format!("Validation successful for {}", header.name));
35:                 Ok(())
36:             }
37:             _ => {
38:                 self.log(LogLevel::Trace, "Skipping analysis for non-behavior discourse");
39:                 Ok(())
40:             }
41:         }
42:     }
43: }
</file>

<file path="src/application/use_cases/layout_service.rs">
 1: use crate::application::ports::compiler_ports::Token;
 2: use crate::application::options::LogLevel;
 3: use chrono::Local;
 4: pub struct LayoutService {
 5:     indent_stack: Vec<usize>,
 6:     pub log_level: LogLevel,
 7: }
 8: impl LayoutService {
 9:     pub fn new(log_level: LogLevel) -> Self {
10:         Self {
11:             indent_stack: vec![0],
12:             log_level,
13:         }
14:     }
15:     fn log(&self, level: LogLevel, message: &str) {
16:         if level <= self.log_level && level != LogLevel::None {
17:             let timestamp = Local::now().to_rfc3339();
18:             eprintln!("[{}] {:?}: [LayoutService] {}", timestamp, level, message);
19:         }
20:     }
21:     pub fn process(&mut self, source: &str, tokens: Vec<Token>) -> Vec<Token> {
22:         self.log(LogLevel::Info, "Starting layout processing");
23:         let mut result = Vec::new();
24:         let lines: Vec<&str> = source.lines().collect();
25:         let mut line_idx = 0;
26:         for token in tokens {
27:             if let Token::LineStart(indent) = token {
28:                 self.log(LogLevel::Trace, &format!("Processing LineStart with indent {}", indent));
29:                 while line_idx < lines.len() {
30:                     let content = lines[line_idx].trim();
31:                     if content.is_empty() || content.starts_with("--") {
32:                         self.log(LogLevel::Trace, &format!("Skipping empty or comment line: {}", line_idx));
33:                         line_idx += 1;
34:                         continue;
35:                     }
36:                     break;
37:                 }
38:                 if line_idx < lines.len() {
39:                     let current_level = *self.indent_stack.last().unwrap();
40:                     if indent > current_level {
41:                         self.log(LogLevel::Debug, &format!("Increasing indent: {} -> {}", current_level, indent));
42:                         self.indent_stack.push(indent);
43:                         result.push(Token::Indent);
44:                     } else if indent < current_level {
45:                         self.log(LogLevel::Debug, &format!("Decreasing indent: {} -> {}", current_level, indent));
46:                         while self.indent_stack.len() > 1 && indent < *self.indent_stack.last().unwrap() {
47:                             self.indent_stack.pop();
48:                             result.push(Token::Dedent);
49:                         }
50:                     }
51:                     line_idx += 1;
52:                 }
53:                 continue;
54:             }
55:             self.log(LogLevel::Trace, &format!("Preserving token: {:?}", token));
56:             result.push(token);
57:         }
58:         self.log(LogLevel::Debug, &format!("Cleaning up remaining indent stack (size {})", self.indent_stack.len()));
59:         while self.indent_stack.len() > 1 {
60:             self.indent_stack.pop();
61:             result.push(Token::Dedent);
62:         }
63:         self.log(LogLevel::Info, &format!("Layout processing complete: {} tokens", result.len()));
64:         result
65:     }
66: }
</file>

<file path="src/application/use_cases/lowering_service.rs">
 1: use crate::domain::entities::ast::{Discourse, Expression, BehaviorHeader, Argument};
 2: use crate::domain::entities::hir::{HirDiscourse, HirExpression, HirBehaviorHeader, HirArgument, HirLiteral};
 3: use crate::domain::entities::types::OnuType;
 4: use crate::application::use_cases::registry_service::RegistryService;
 5: pub struct LoweringService;
 6: impl LoweringService {
 7:     pub fn lower_discourse(discourse: &Discourse, registry: &RegistryService) -> HirDiscourse {
 8:         match discourse {
 9:             Discourse::Module { name, concern } => HirDiscourse::Module {
10:                 name: name.clone(),
11:                 concern: concern.clone(),
12:             },
13:             Discourse::Behavior { header, body } => {
14:                 let mut hir_header = Self::lower_header(header);
15:                 if header.name == "main" || header.name == "run" {
16:                     hir_header.args.insert(0, HirArgument { name: "__argc".to_string(), typ: OnuType::I32, is_observation: false });
17:                     hir_header.args.insert(1, HirArgument { name: "__argv".to_string(), typ: OnuType::U64, is_observation: false });
18:                 }
19:                 HirDiscourse::Behavior {
20:                     header: hir_header,
21:                     body: Self::lower_expression(body, registry),
22:                 }
23:             },
24:             Discourse::Shape { name, behaviors } => HirDiscourse::Shape {
25:                 name: name.clone(),
26:                 behaviors: behaviors.iter().map(Self::lower_header).collect()
27:             },
28:         }
29:     }
30:     fn lower_header(header: &BehaviorHeader) -> HirBehaviorHeader {
31:         HirBehaviorHeader {
32:             name: header.name.clone(),
33:             is_effect: header.is_effect,
34:             args: header.takes.iter().map(Self::lower_argument).collect(),
35:             return_type: header.delivers.0.clone(),
36:         }
37:     }
38:     fn lower_argument(arg: &Argument) -> HirArgument {
39:         HirArgument {
40:             name: arg.name.clone(),
41:             typ: arg.type_info.onu_type.clone(),
42:             is_observation: arg.type_info.is_observation,
43:         }
44:     }
45:     fn lower_expression(expr: &Expression, registry: &RegistryService) -> HirExpression {
46:         match expr {
47:             Expression::I128(n) => HirExpression::Literal(HirLiteral::I64(*n as i64)),
48:             Expression::F64(n) => HirExpression::Literal(HirLiteral::F64(*n)),
49:             Expression::Boolean(b) => HirExpression::Literal(HirLiteral::Boolean(*b)),
50:             Expression::Text(s) => HirExpression::Literal(HirLiteral::Text(s.clone())),
51:             Expression::Nothing => HirExpression::Literal(HirLiteral::Nothing),
52:             Expression::Identifier(name) => {
53:                 if registry.get_signature(name).is_some() {
54:                     HirExpression::Call { name: name.clone(), args: vec![] }
55:                 } else {
56:                     HirExpression::Variable(name.clone(), false)
57:                 }
58:             },
59:             Expression::BehaviorCall { name, args } => HirExpression::Call {
60:                 name: name.clone(),
61:                 args: args.iter().map(|e| Self::lower_expression(e, registry)).collect(),
62:             },
63:             Expression::Derivation { name, value, body, .. } => HirExpression::Derivation {
64:                 name: name.clone(),
65:                 typ: OnuType::I64,
66:                 value: Box::new(Self::lower_expression(value, registry)),
67:                 body: Box::new(Self::lower_expression(body, registry)),
68:             },
69:             Expression::If { condition, then_branch, else_branch } => HirExpression::If {
70:                 condition: Box::new(Self::lower_expression(condition, registry)),
71:                 then_branch: Box::new(Self::lower_expression(then_branch, registry)),
72:                 else_branch: Box::new(Self::lower_expression(else_branch, registry)),
73:             },
74:             Expression::Block(exprs) => HirExpression::Block(
75:                 exprs.iter().map(|e| Self::lower_expression(e, registry)).collect()
76:             ),
77:             Expression::Emit(e) => HirExpression::Emit(Box::new(Self::lower_expression(e, registry))),
78:             Expression::Tuple(exprs) => HirExpression::Tuple(
79:                 exprs.iter().map(|e| Self::lower_expression(e, registry)).collect()
80:             ),
81:             Expression::ActsAs { subject, .. } => Self::lower_expression(subject, registry),
82:             Expression::Broadcasts(e) => HirExpression::Emit(Box::new(Self::lower_expression(e, registry))),
83:             Expression::Drop(e) => HirExpression::Drop(Box::new(Self::lower_expression(e, registry))),
84:             Expression::Matrix { .. } => HirExpression::Literal(HirLiteral::Nothing),
85:             Expression::I8(n) => HirExpression::Literal(HirLiteral::I64(*n as i64)),
86:             Expression::I16(n) => HirExpression::Literal(HirLiteral::I64(*n as i64)),
87:             Expression::I32(n) => HirExpression::Literal(HirLiteral::I64(*n as i64)),
88:             Expression::I64(n) => HirExpression::Literal(HirLiteral::I64(*n)),
89:             Expression::U8(n) => HirExpression::Literal(HirLiteral::I64(*n as i64)),
90:             Expression::U16(n) => HirExpression::Literal(HirLiteral::I64(*n as i64)),
91:             Expression::U32(n) => HirExpression::Literal(HirLiteral::I64(*n as i64)),
92:             Expression::U64(n) => HirExpression::Literal(HirLiteral::I64(*n as i64)),
93:             Expression::F32(n) => HirExpression::Literal(HirLiteral::F64(*n as u64)),
94:             _ => HirExpression::Literal(HirLiteral::Nothing),
95:         }
96:     }
97: }
</file>

<file path="src/application/use_cases/mir_builder.rs">
 1: use crate::domain::entities::mir::{MirFunction, BasicBlock, MirInstruction, MirTerminator};
 2: use crate::domain::entities::types::OnuType;
 3: use std::collections::HashMap;
 4: pub struct MirBuilder {
 5:     name: String,
 6:     return_type: OnuType,
 7:     args: Vec<crate::domain::entities::mir::MirArgument>,
 8:     blocks: Vec<BasicBlock>,
 9:     current_block_idx: Option<usize>,
10:     next_ssa: usize,
11:     scopes: Vec<HashMap<String, usize>>,
12: }
13: impl MirBuilder {
14:     pub fn new(name: String, return_type: OnuType) -> Self {
15:         let entry_block = BasicBlock {
16:             id: 0,
17:             instructions: Vec::new(),
18:             terminator: MirTerminator::Unreachable,
19:         };
20:         Self {
21:             name,
22:             return_type,
23:             args: Vec::new(),
24:             blocks: vec![entry_block],
25:             current_block_idx: Some(0),
26:             next_ssa: 0,
27:             scopes: vec![HashMap::new()],
28:         }
29:     }
30:     pub fn add_arg(&mut self, name: String, typ: OnuType, ssa_var: usize) {
31:         self.args.push(crate::domain::entities::mir::MirArgument { name, typ, ssa_var });
32:     }
33:     pub fn new_ssa(&mut self) -> usize {
34:         let id = self.next_ssa;
35:         self.next_ssa += 1;
36:         id
37:     }
38:     pub fn define_variable(&mut self, name: &str, ssa_var: usize) {
39:         if let Some(scope) = self.scopes.last_mut() {
40:             scope.insert(name.to_string(), ssa_var);
41:         }
42:     }
43:     pub fn resolve_variable(&self, name: &str) -> Option<usize> {
44:         for scope in self.scopes.iter().rev() {
45:             if let Some(id) = scope.get(name) {
46:                 return Some(*id);
47:             }
48:         }
49:         None
50:     }
51:     pub fn enter_scope(&mut self) {
52:         self.scopes.push(HashMap::new());
53:     }
54:     pub fn exit_scope(&mut self) {
55:         self.scopes.pop();
56:     }
57:     pub fn create_block(&mut self) -> usize {
58:         let id = self.blocks.len();
59:         self.blocks.push(BasicBlock {
60:             id,
61:             instructions: Vec::new(),
62:             terminator: MirTerminator::Unreachable,
63:         });
64:         id
65:     }
66:     pub fn switch_to_block(&mut self, id: usize) {
67:         if id < self.blocks.len() {
68:             self.current_block_idx = Some(id);
69:         }
70:     }
71:     pub fn emit(&mut self, inst: MirInstruction) {
72:         if let Some(idx) = self.current_block_idx {
73:             self.blocks[idx].instructions.push(inst);
74:         }
75:     }
76:     pub fn terminate(&mut self, term: MirTerminator) {
77:         if let Some(idx) = self.current_block_idx {
78:             self.blocks[idx].terminator = term;
79:         }
80:     }
81:     pub fn get_current_block_id(&self) -> Option<usize> {
82:         self.current_block_idx.map(|idx| self.blocks[idx].id)
83:     }
84:     pub fn build(self) -> MirFunction {
85:         MirFunction {
86:             name: self.name,
87:             args: self.args,
88:             return_type: self.return_type,
89:             blocks: self.blocks,
90:         }
91:     }
92: }
</file>

<file path="src/application/use_cases/mir_lowering_service.rs">
  1: use crate::domain::entities::hir::{HirDiscourse, HirExpression, HirBehaviorHeader, HirLiteral};
  2: use crate::domain::entities::mir::*;
  3: use crate::domain::entities::types::OnuType;
  4: use crate::application::use_cases::mir_builder::MirBuilder;
  5: use crate::domain::entities::error::OnuError;
  6: use crate::application::ports::environment::EnvironmentPort;
  7: use crate::application::options::LogLevel;
  8: pub struct MirLoweringService<'a, E: EnvironmentPort> {
  9:     pub env: &'a E,
 10: }
 11: impl<'a, E: EnvironmentPort> MirLoweringService<'a, E> {
 12:     pub fn new(env: &'a E) -> Self {
 13:         Self { env }
 14:     }
 15:     fn log(&self, level: LogLevel, message: &str) {
 16:         self.env.log(level, &format!("[MirLowering] {}", message));
 17:     }
 18:     pub fn lower_program(&self, discourses: &[HirDiscourse]) -> Result<MirProgram, OnuError> {
 19:         self.log(LogLevel::Info, "Starting MIR lowering for program");
 20:         let mut functions = Vec::new();
 21:         for discourse in discourses {
 22:             if let HirDiscourse::Behavior { header, body } = discourse {
 23:                 functions.push(self.lower_function(header, body)?);
 24:             }
 25:         }
 26:         self.log(LogLevel::Info, &format!("MIR lowering successful: {} functions", functions.len()));
 27:         Ok(MirProgram { functions })
 28:     }
 29:     fn lower_function(&self, header: &HirBehaviorHeader, body: &HirExpression) -> Result<MirFunction, OnuError> {
 30:         self.log(LogLevel::Debug, &format!("Lowering behavior: {}", header.name));
 31:         let mut builder = MirBuilder::new(header.name.clone(), header.return_type.clone());
 32:         for arg in &header.args {
 33:             let ssa_var = builder.new_ssa();
 34:             builder.define_variable(&arg.name, ssa_var);
 35:             builder.add_arg(arg.name.clone(), arg.typ.clone(), ssa_var);
 36:         }
 37:         let result_op = self.lower_expression(body, &mut builder, true)?;
 38:         if builder.get_current_block_id().is_some() {
 39:             builder.terminate(MirTerminator::Return(result_op));
 40:         }
 41:         Ok(builder.build())
 42:     }
 43:     fn lower_expression(&self, expr: &HirExpression, builder: &mut MirBuilder, is_tail: bool) -> Result<MirOperand, OnuError> {
 44:         self.log(LogLevel::Trace, &format!("Lowering expression: {:?}", expr));
 45:         let res = match expr {
 46:             HirExpression::Literal(lit) => {
 47:                 let mir_lit = match lit {
 48:                     HirLiteral::I64(n) => MirLiteral::I64(*n),
 49:                     HirLiteral::F64(n) => MirLiteral::F64(*n),
 50:                     HirLiteral::Boolean(b) => MirLiteral::Boolean(*b),
 51:                     HirLiteral::Text(s) => MirLiteral::Text(s.clone()),
 52:                     HirLiteral::Nothing => MirLiteral::Nothing,
 53:                 };
 54:                 Ok(MirOperand::Constant(mir_lit))
 55:             }
 56:             HirExpression::Variable(name, is_consuming) => {
 57:                 let ssa_var = builder.resolve_variable(name)
 58:                     .ok_or_else(|| OnuError::GrammarViolation {
 59:                         message: format!("Unresolved variable: {}", name),
 60:                         span: crate::domain::entities::error::Span::default()
 61:                     })?;
 62:                 Ok(MirOperand::Variable(ssa_var, *is_consuming))
 63:             }
 64:             HirExpression::Call { name, args } => {
 65:                 let mut mir_args = Vec::new();
 66:                 for arg in args {
 67:                     mir_args.push(self.lower_expression(arg, builder, false)?);
 68:                 }
 69:                 let dest = builder.new_ssa();
 70:                 builder.emit(MirInstruction::Call { dest, name: name.clone(), args: mir_args });
 71:                 Ok(MirOperand::Variable(dest, false))
 72:             }
 73:             HirExpression::Derivation { name, value, body, .. } => {
 74:                 let val_op = self.lower_expression(value, builder, false)?;
 75:                 let ssa_var = builder.new_ssa();
 76:                 builder.emit(MirInstruction::Assign { dest: ssa_var, src: val_op });
 77:                 builder.define_variable(name, ssa_var);
 78:                 self.lower_expression(body, builder, is_tail)
 79:             }
 80:             HirExpression::If { condition, then_branch, else_branch } => {
 81:                 let cond_op = self.lower_expression(condition, builder, false)?;
 82:                 let then_start_id = builder.create_block();
 83:                 let else_start_id = builder.create_block();
 84:                 let merge_id = builder.create_block();
 85:                 let dest = builder.new_ssa();
 86:                 builder.terminate(MirTerminator::CondBranch {
 87:                     condition: cond_op,
 88:                     then_block: then_start_id,
 89:                     else_block: else_start_id
 90:                 });
 91:                 builder.switch_to_block(then_start_id);
 92:                 let then_res = self.lower_expression(then_branch, builder, is_tail)?;
 93:                 if builder.get_current_block_id().is_some() {
 94:                     builder.emit(MirInstruction::Assign { dest, src: then_res });
 95:                     builder.terminate(MirTerminator::Branch(merge_id));
 96:                 }
 97:                 builder.switch_to_block(else_start_id);
 98:                 let else_res = self.lower_expression(else_branch, builder, is_tail)?;
 99:                 if builder.get_current_block_id().is_some() {
100:                     builder.emit(MirInstruction::Assign { dest, src: else_res });
101:                     builder.terminate(MirTerminator::Branch(merge_id));
102:                 }
103:                 builder.switch_to_block(merge_id);
104:                 Ok(MirOperand::Variable(dest, false))
105:             }
106:             HirExpression::Block(exprs) => {
107:                 let mut last_op = MirOperand::Constant(MirLiteral::Nothing);
108:                 for expr in exprs {
109:                     last_op = self.lower_expression(expr, builder, false)?;
110:                 }
111:                 Ok(last_op)
112:             }
113:             HirExpression::Emit(e) => {
114:                 let op = self.lower_expression(e, builder, false)?;
115:                 builder.emit(MirInstruction::Emit(op));
116:                 Ok(MirOperand::Constant(MirLiteral::Nothing))
117:             }
118:             HirExpression::Drop(e) => {
119:                 let op = self.lower_expression(e, builder, false)?;
120:                 if let MirOperand::Variable(ssa_var, _) = op {
121:                     builder.emit(MirInstruction::Drop { ssa_var, typ: OnuType::Nothing });
122:                 }
123:                 Ok(MirOperand::Constant(MirLiteral::Nothing))
124:             }
125:             HirExpression::Index { subject, index } => {
126:                 let op = self.lower_expression(subject, builder, false)?;
127:                 let dest = builder.new_ssa();
128:                 builder.emit(MirInstruction::Index { dest, subject: op, index: *index });
129:                 Ok(MirOperand::Variable(dest, false))
130:             }
131:             _ => Ok(MirOperand::Constant(MirLiteral::Nothing)),
132:         };
133:         self.log(LogLevel::Trace, &format!("Expression result: {:?}", res));
134:         res
135:     }
136: }
</file>

<file path="src/application/use_cases/module_service.rs">
 1: use crate::application::use_cases::registry_service::RegistryService;
 2: use crate::domain::entities::registry::BuiltInModule;
 3: use crate::application::options::LogLevel;
 4: use chrono::Local;
 5: pub struct ModuleService {
 6:     pub log_level: LogLevel,
 7: }
 8: impl ModuleService {
 9:     pub fn new(log_level: LogLevel) -> Self {
10:         Self { log_level }
11:     }
12:     fn log(&self, level: LogLevel, message: &str) {
13:         if level <= self.log_level && level != LogLevel::None {
14:             let timestamp = Local::now().to_rfc3339();
15:             eprintln!("[{}] {:?}: [ModuleService] {}", timestamp, level, message);
16:         }
17:     }
18:     pub fn register_module(&self, registry: &mut RegistryService, module: &dyn BuiltInModule) {
19:         self.log(LogLevel::Debug, &format!("Registering module: {}", module.name()));
20:         module.register(registry.symbols_mut());
21:     }
22: }
</file>

<file path="src/application/mod.rs">
1: pub mod ports;
2: pub mod use_cases;
3: pub mod options;
</file>

<file path="src/application/options.rs">
 1: #[derive(Debug, Clone, PartialEq, Eq)]
 2: pub struct CompilationOptions {
 3:     pub stop_after: Option<CompilerStage>,
 4:     pub log_level: LogLevel,
 5:     pub emit_hir: bool,
 6:     pub emit_mir: bool,
 7:     pub emit_tokens: bool,
 8:     pub optimization_level: u32,
 9: }
10: #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
11: pub enum LogLevel {
12:     None = 0,
13:     Error = 1,
14:     Warn = 2,
15:     Info = 3,
16:     Debug = 4,
17:     Trace = 5,
18: }
19: #[derive(Debug, Clone, Copy, PartialEq, Eq)]
20: pub enum CompilerStage {
21:     Lexing,
22:     Parsing,
23:     Analysis,
24:     Mir,
25:     Codegen,
26:     Realization,
27: }
28: impl CompilerStage {
29:     pub fn from_str(s: &str) -> Option<Self> {
30:         match s.to_lowercase().as_str() {
31:             "lexing" => Some(CompilerStage::Lexing),
32:             "parsing" => Some(CompilerStage::Parsing),
33:             "analysis" => Some(CompilerStage::Analysis),
34:             "mir" => Some(CompilerStage::Mir),
35:             "codegen" => Some(CompilerStage::Codegen),
36:             "realization" => Some(CompilerStage::Realization),
37:             _ => None,
38:         }
39:     }
40: }
41: impl Default for CompilationOptions {
42:     fn default() -> Self {
43:         Self {
44:             stop_after: None,
45:             log_level: LogLevel::Info,
46:             emit_hir: false,
47:             emit_mir: false,
48:             emit_tokens: false,
49:             optimization_level: 0,
50:         }
51:     }
52: }
</file>

<file path="src/domain/entities/ast.rs">
 1: use crate::domain::entities::types::OnuType;
 2: #[derive(Debug, PartialEq, Eq, Clone)]
 3: pub enum Discourse {
 4:     Module { name: String, concern: String },
 5:     Shape { name: String, behaviors: Vec<BehaviorHeader> },
 6:     Behavior { header: BehaviorHeader, body: Expression },
 7: }
 8: #[derive(Debug, PartialEq, Eq, Clone, Hash)]
 9: pub struct TypeInfo {
10:     pub onu_type: OnuType,
11:     pub display_name: String,
12:     pub via_role: Option<String>,
13:     pub is_observation: bool,
14: }
15: #[derive(Debug, PartialEq, Eq, Clone, Hash)]
16: pub struct Argument {
17:     pub name: String,
18:     pub type_info: TypeInfo,
19: }
20: #[derive(Debug, PartialEq, Eq, Clone, Hash)]
21: pub struct ReturnType(pub OnuType);
22: #[derive(Debug, Clone, PartialEq, Eq, Hash)]
23: pub enum Expression {
24:     I8(i8), I16(i16), I32(i32), I64(i64), I128(i128),
25:     U8(u8), U16(u16), U32(u32), U64(u64), U128(u128),
26:     F32(u32),
27:     F64(u64),
28:     Boolean(bool),
29:     Text(String),
30:     Identifier(String),
31:     Nothing,
32:     Tuple(Vec<Expression>),
33:     Array(Vec<Expression>),
34:     Matrix { rows: usize, cols: usize, data: Vec<Expression> },
35:     Emit(Box<Expression>),
36:     Broadcasts(Box<Expression>),
37:     Derivation {
38:         name: String,
39:         type_info: Option<TypeInfo>,
40:         value: Box<Expression>,
41:         body: Box<Expression>
42:     },
43:     ActsAs {
44:         subject: Box<Expression>,
45:         shape: String,
46:     },
47:     BehaviorCall { name: String, args: Vec<Expression> },
48:     If {
49:         condition: Box<Expression>,
50:         then_branch: Box<Expression>,
51:         else_branch: Box<Expression>,
52:     },
53:     Block(Vec<Expression>),
54:     Drop(Box<Expression>),
55: }
56: #[derive(Debug, PartialEq, Eq, Clone)]
57: pub struct BehaviorHeader {
58:     pub name: String,
59:     pub is_effect: bool,
60:     pub intent: String,
61:     pub takes: Vec<Argument>,
62:     pub delivers: ReturnType,
63:     pub diminishing: Option<String>,
64:     pub skip_termination_check: bool,
65: }
</file>

<file path="src/domain/entities/core_module.rs">
 1: use crate::domain::entities::registry::{BuiltInModule, SymbolTable, BehaviorSignature};
 2: use crate::domain::entities::types::OnuType;
 3: pub struct CoreModule;
 4: impl BuiltInModule for CoreModule {
 5:     fn name(&self) -> &str { "Core" }
 6:     fn register(&self, table: &mut SymbolTable) {
 7:         let core_builtins = vec![
 8:             ("joined-with", BehaviorSignature { input_types: vec![OnuType::Strings, OnuType::Strings], return_type: OnuType::Strings, arg_is_observation: vec![true, true] }),
 9:             ("len", BehaviorSignature { input_types: vec![OnuType::Strings], return_type: OnuType::I64, arg_is_observation: vec![true] }),
10:             ("char-at", BehaviorSignature { input_types: vec![OnuType::Strings, OnuType::I64], return_type: OnuType::I64, arg_is_observation: vec![true, false] }),
11:             ("as-text", BehaviorSignature { input_types: vec![OnuType::I64], return_type: OnuType::Strings, arg_is_observation: vec![false] }),
12:             ("set-char", BehaviorSignature { input_types: vec![OnuType::Strings, OnuType::I64, OnuType::I64], return_type: OnuType::Strings, arg_is_observation: vec![false, false, false] }),
13:             ("inplace-set-char", BehaviorSignature { input_types: vec![OnuType::Strings, OnuType::I64, OnuType::I64], return_type: OnuType::Strings, arg_is_observation: vec![false, false, false] }),
14:             ("tail-of", BehaviorSignature { input_types: vec![OnuType::Strings], return_type: OnuType::Strings, arg_is_observation: vec![false] }),
15:             ("init-of", BehaviorSignature { input_types: vec![OnuType::Strings], return_type: OnuType::Strings, arg_is_observation: vec![false] }),
16:             ("char-from-code", BehaviorSignature { input_types: vec![OnuType::I64], return_type: OnuType::Strings, arg_is_observation: vec![false] }),
17:             ("duplicated-as", BehaviorSignature { input_types: vec![OnuType::Strings], return_type: OnuType::Strings, arg_is_observation: vec![true] }),
18:             ("clears", BehaviorSignature { input_types: vec![OnuType::Nothing], return_type: OnuType::Nothing, arg_is_observation: vec![false] }),
19:             ("creates-map", BehaviorSignature { input_types: vec![], return_type: OnuType::HashMap(Box::new(OnuType::Nothing), Box::new(OnuType::Nothing)), arg_is_observation: vec![] }),
20:             ("creates-tree", BehaviorSignature { input_types: vec![], return_type: OnuType::Tree(Box::new(OnuType::Nothing)), arg_is_observation: vec![] }),
21:             ("as-integer", BehaviorSignature { input_types: vec![OnuType::Strings], return_type: OnuType::I64, arg_is_observation: vec![true] }),
22:             ("receives-entropy", BehaviorSignature { input_types: vec![], return_type: OnuType::I64, arg_is_observation: vec![] }),
23:         ];
24:         for (name, sig) in core_builtins {
25:             table.add_signature(name, sig);
26:             table.mark_implemented(name);
27:         }
28:     }
29: }
30: pub struct StandardMathModule;
31: impl BuiltInModule for StandardMathModule {
32:     fn name(&self) -> &str { "StandardMath" }
33:     fn register(&self, table: &mut SymbolTable) {
34:         let math_signatures = vec![
35:             ("added-to", BehaviorSignature { input_types: vec![OnuType::I64, OnuType::I64], return_type: OnuType::I64, arg_is_observation: vec![false, false] }),
36:             ("decreased-by", BehaviorSignature { input_types: vec![OnuType::I64, OnuType::I64], return_type: OnuType::I64, arg_is_observation: vec![false, false] }),
37:             ("scales-by", BehaviorSignature { input_types: vec![OnuType::I64, OnuType::I64], return_type: OnuType::I64, arg_is_observation: vec![false, false] }),
38:             ("partitions-by", BehaviorSignature { input_types: vec![OnuType::I64, OnuType::I64], return_type: OnuType::I64, arg_is_observation: vec![false, false] }),
39:             ("matches", BehaviorSignature { input_types: vec![OnuType::I64, OnuType::I64], return_type: OnuType::I64, arg_is_observation: vec![false, false] }),
40:             ("exceeds", BehaviorSignature { input_types: vec![OnuType::I64, OnuType::I64], return_type: OnuType::I64, arg_is_observation: vec![false, false] }),
41:             ("falls-short-of", BehaviorSignature { input_types: vec![OnuType::I64, OnuType::I64], return_type: OnuType::I64, arg_is_observation: vec![false, false] }),
42:         ];
43:         for (name, sig) in math_signatures {
44:             table.add_signature(name, sig);
45:             table.mark_implemented(name);
46:         }
47:     }
48: }
</file>

<file path="src/domain/entities/error.rs">
 1: #[derive(Debug, Clone, PartialEq, Eq)]
 2: pub struct Span {
 3:     pub line: usize,
 4:     pub column: usize,
 5: }
 6: impl Default for Span {
 7:     fn default() -> Self {
 8:         Self { line: 0, column: 0 }
 9:     }
10: }
11: #[derive(Debug, Clone, PartialEq, Eq)]
12: pub enum OnuError {
13:     GrammarViolation { message: String, span: Span },
14:     ResourceViolation { message: String, span: Span },
15:     AgencyViolation { message: String, span: Span },
16:     MonomorphizationError { message: String },
17:     CodeGenError { message: String },
18:     OwnershipViolation { message: String, span: Span },
19:     BehaviorConflict { message: String, span: Span },
20: }
21: impl From<String> for OnuError {
22:     fn from(message: String) -> Self {
23:         OnuError::ResourceViolation { message, span: Span::default() }
24:     }
25: }
</file>

<file path="src/domain/entities/hir.rs">
 1: use crate::domain::entities::types::OnuType;
 2: #[derive(Debug, Clone, PartialEq)]
 3: pub enum HirDiscourse {
 4:     Module { name: String, concern: String },
 5:     Shape { name: String, behaviors: Vec<HirBehaviorHeader> },
 6:     Behavior { header: HirBehaviorHeader, body: HirExpression },
 7: }
 8: #[derive(Debug, Clone, PartialEq)]
 9: pub struct HirBehaviorHeader {
10:     pub name: String,
11:     pub is_effect: bool,
12:     pub args: Vec<HirArgument>,
13:     pub return_type: OnuType,
14: }
15: #[derive(Debug, Clone, PartialEq)]
16: pub struct HirArgument {
17:     pub name: String,
18:     pub typ: OnuType,
19:     pub is_observation: bool,
20: }
21: #[derive(Debug, Clone, PartialEq)]
22: pub enum HirExpression {
23:     Literal(HirLiteral),
24:     Variable(String, bool),
25:     Call { name: String, args: Vec<HirExpression> },
26:     Derivation {
27:         name: String,
28:         typ: OnuType,
29:         value: Box<HirExpression>,
30:         body: Box<HirExpression>
31:     },
32:     If {
33:         condition: Box<HirExpression>,
34:         then_branch: Box<HirExpression>,
35:         else_branch: Box<HirExpression>
36:     },
37:     ActsAs {
38:         subject: Box<HirExpression>,
39:         shape: String
40:     },
41:     Tuple(Vec<HirExpression>),
42:     Index {
43:         subject: Box<HirExpression>,
44:         index: usize
45:     },
46:     Block(Vec<HirExpression>),
47:     Emit(Box<HirExpression>),
48:     Drop(Box<HirExpression>),
49: }
50: #[derive(Debug, Clone, PartialEq)]
51: pub enum HirLiteral {
52:     I64(i64),
53:     F64(u64),
54:     Boolean(bool),
55:     Text(String),
56:     Nothing,
57: }
</file>

<file path="src/domain/entities/mir.rs">
 1: use crate::domain::entities::types::OnuType;
 2: #[derive(Debug, Clone, PartialEq)]
 3: pub struct MirProgram {
 4:     pub functions: Vec<MirFunction>,
 5: }
 6: #[derive(Debug, Clone, PartialEq)]
 7: pub struct MirFunction {
 8:     pub name: String,
 9:     pub args: Vec<MirArgument>,
10:     pub return_type: OnuType,
11:     pub blocks: Vec<BasicBlock>,
12: }
13: #[derive(Debug, Clone, PartialEq)]
14: pub struct MirArgument {
15:     pub name: String,
16:     pub typ: OnuType,
17:     pub ssa_var: usize,
18: }
19: #[derive(Debug, Clone, PartialEq)]
20: pub struct BasicBlock {
21:     pub id: usize,
22:     pub instructions: Vec<MirInstruction>,
23:     pub terminator: MirTerminator,
24: }
25: #[derive(Debug, Clone, PartialEq)]
26: pub enum MirInstruction {
27:     Assign { dest: usize, src: MirOperand },
28:     BinaryOperation { dest: usize, op: MirBinOp, lhs: MirOperand, rhs: MirOperand },
29:     Call { dest: usize, name: String, args: Vec<MirOperand> },
30:     Tuple { dest: usize, elements: Vec<MirOperand> },
31:     Index { dest: usize, subject: MirOperand, index: usize },
32:     Emit(MirOperand),
33:     Drop { ssa_var: usize, typ: OnuType },
34: }
35: #[derive(Debug, Clone, PartialEq)]
36: pub enum MirBinOp {
37:     Add, Sub, Mul, Div, Eq, Gt, Lt,
38: }
39: #[derive(Debug, Clone, PartialEq)]
40: pub enum MirOperand {
41:     Constant(MirLiteral),
42:     Variable(usize, bool),
43: }
44: #[derive(Debug, Clone, PartialEq)]
45: pub enum MirLiteral {
46:     I64(i64),
47:     F64(u64),
48:     Boolean(bool),
49:     Text(String),
50:     Nothing,
51: }
52: #[derive(Debug, Clone, PartialEq)]
53: pub enum MirTerminator {
54:     Return(MirOperand),
55:     Branch(usize),
56:     CondBranch { condition: MirOperand, then_block: usize, else_block: usize },
57:     Unreachable,
58: }
</file>

<file path="src/domain/entities/types.rs">
 1: #[derive(Debug, PartialEq, Eq, Clone, Hash)]
 2: pub enum OnuType {
 3:     I8, I16, I32, I64, I128,
 4:     U8, U16, U32, U64, U128,
 5:     F32, F64,
 6:     Boolean,
 7:     Strings,
 8:     Matrix,
 9:     Nothing,
10:     Tuple(Vec<OnuType>),
11:     Array(Box<OnuType>),
12:     HashMap(Box<OnuType>, Box<OnuType>),
13:     Tree(Box<OnuType>),
14:     Shape(String),
15: }
16: impl OnuType {
17:     pub fn from_name(name: &str) -> Option<Self> {
18:         match name {
19:             "integer" | "i64" => Some(OnuType::I64),
20:             "float" | "f64" => Some(OnuType::F64),
21:             "boolean" => Some(OnuType::Boolean),
22:             "string" => Some(OnuType::Strings),
23:             "nothing" => Some(OnuType::Nothing),
24:             _ => None,
25:         }
26:     }
27:     pub fn is_resource(&self) -> bool {
28:         matches!(self, OnuType::Strings | OnuType::Matrix | OnuType::Array(_) | OnuType::HashMap(_, _) | OnuType::Tree(_))
29:     }
30: }
</file>

<file path="src/domain/rules/dry_enforcement.rs">
 1: use crate::domain::entities::ast::Discourse;
 2: use crate::domain::entities::error::{OnuError, Span};
 3: use std::collections::HashMap;
 4: pub struct DryEnforcementRule {
 5:     defined_behaviors: HashMap<String, String>,
 6: }
 7: impl DryEnforcementRule {
 8:     pub fn new() -> Self {
 9:         Self { defined_behaviors: HashMap::new() }
10:     }
11:     pub fn validate(&mut self, discourses: &[Discourse]) -> Result<(), OnuError> {
12:         for discourse in discourses {
13:             if let Discourse::Behavior { header, .. } = discourse {
14:                 let normalized = header.name.replace('-', "_");
15:                 if let Some(existing_name) = self.defined_behaviors.get(&normalized) {
16:                     return Err(OnuError::BehaviorConflict {
17:                         message: format!("Behavior conflict: '{}' normalized to '{}' conflicts with existing behavior '{}'", header.name, normalized, existing_name),
18:                         span: Span::default(),
19:                     });
20:                 }
21:                 self.defined_behaviors.insert(normalized, header.name.clone());
22:             }
23:         }
24:         Ok(())
25:     }
26: }
</file>

<file path="src/domain/rules/liveness.rs">
 1: use crate::domain::entities::hir::HirExpression;
 2: use std::collections::HashSet;
 3: pub struct LivenessRule;
 4: impl LivenessRule {
 5:     pub fn new() -> Self {
 6:         Self
 7:     }
 8:     pub fn analyze(&self, expr: &mut HirExpression) {
 9:         let mut live_vars = HashSet::new();
10:         self.visit_backward(expr, &mut live_vars);
11:     }
12:     fn visit_backward(&self, expr: &mut HirExpression, live_vars: &mut HashSet<String>) {
13:         match expr {
14:             HirExpression::Variable(name, is_consuming) => {
15:                 if !live_vars.contains(name) {
16:                     *is_consuming = true;
17:                     live_vars.insert(name.clone());
18:                 } else {
19:                     *is_consuming = false;
20:                 }
21:             }
22:             HirExpression::Call { args, .. } => {
23:                 for arg in args.iter_mut().rev() {
24:                     self.visit_backward(arg, live_vars);
25:                 }
26:             }
27:             HirExpression::Derivation { name, value, body, .. } => {
28:                 self.visit_backward(body, live_vars);
29:                 live_vars.remove(name);
30:                 self.visit_backward(value, live_vars);
31:             }
32:             HirExpression::If { condition, then_branch, else_branch } => {
33:                 let mut then_live = live_vars.clone();
34:                 let mut else_live = live_vars.clone();
35:                 self.visit_backward(then_branch, &mut then_live);
36:                 self.visit_backward(else_branch, &mut else_live);
37:                 live_vars.clear();
38:                 live_vars.extend(then_live);
39:                 live_vars.extend(else_live);
40:                 self.visit_backward(condition, live_vars);
41:             }
42:             HirExpression::Block(exprs) => {
43:                 for e in exprs.iter_mut().rev() {
44:                     self.visit_backward(e, live_vars);
45:                 }
46:             }
47:             HirExpression::Emit(e) => {
48:                 self.visit_backward(e, live_vars);
49:             }
50:             HirExpression::Tuple(elements) => {
51:                 for e in elements.iter_mut().rev() {
52:                     self.visit_backward(e, live_vars);
53:                 }
54:             }
55:             HirExpression::Index { subject, .. } => {
56:                 self.visit_backward(subject, live_vars);
57:             }
58:             HirExpression::ActsAs { subject, .. } => {
59:                 self.visit_backward(subject, live_vars);
60:             }
61:             _ => {}
62:         }
63:     }
64: }
</file>

<file path="src/domain/rules/mod.rs">
1: pub mod dry_enforcement; pub mod ownership; pub mod liveness;
</file>

<file path="src/domain/rules/ownership.rs">
 1: use crate::domain::entities::hir::{HirExpression, HirBehaviorHeader};
 2: use crate::application::use_cases::registry_service::RegistryService;
 3: use crate::domain::entities::error::OnuError;
 4: use crate::application::options::LogLevel;
 5: use std::collections::HashSet;
 6: use chrono::Local;
 7: pub struct OwnershipRule<'a> {
 8:     pub registry: &'a RegistryService,
 9: }
10: impl<'a> OwnershipRule<'a> {
11:     pub fn new(registry: &'a RegistryService) -> Self {
12:         Self { registry }
13:     }
14:     fn log(&self, level: LogLevel, message: &str) {
15:         if level <= self.registry.log_level && level != LogLevel::None {
16:             let timestamp = Local::now().to_rfc3339();
17:             eprintln!("[{}] {:?}: [OwnershipRule] {}", timestamp, level, message);
18:         }
19:     }
20:     pub fn validate(&self, header: &HirBehaviorHeader, body: &HirExpression) -> Result<(), OnuError> {
21:         self.log(LogLevel::Debug, &format!("Validating ownership for behavior: {}", header.name));
22:         let mut owned_vars = HashSet::new();
23:         for arg in &header.args {
24:             if !arg.is_observation {
25:                 owned_vars.insert(arg.name.clone());
26:             }
27:         }
28:         self.check_expression(body, &mut owned_vars)?;
29:         self.log(LogLevel::Debug, "Ownership validation successful");
30:         Ok(())
31:     }
32:     fn check_expression(&self, expr: &HirExpression, owned_vars: &mut HashSet<String>) -> Result<(), OnuError> {
33:         match expr {
34:             HirExpression::Variable(name, is_consuming) => {
35:                 if *is_consuming {
36:                     if !owned_vars.remove(name) {
37:                         return Err(OnuError::OwnershipViolation {
38:                             message: format!("Attempt to consume variable '{}' without ownership", name),
39:                             span: crate::domain::entities::error::Span::default()
40:                         });
41:                     }
42:                 }
43:             }
44:             HirExpression::Call { args, .. } => {
45:                 for arg in args {
46:                     self.check_expression(arg, owned_vars)?;
47:                 }
48:             }
49:             HirExpression::Derivation { name, value, body, .. } => {
50:                 self.check_expression(value, owned_vars)?;
51:                 owned_vars.insert(name.clone());
52:                 self.check_expression(body, owned_vars)?;
53:             }
54:             HirExpression::If { condition, then_branch, else_branch } => {
55:                 self.check_expression(condition, owned_vars)?;
56:                 let mut then_owned = owned_vars.clone();
57:                 let mut else_owned = owned_vars.clone();
58:                 self.check_expression(then_branch, &mut then_owned)?;
59:                 self.check_expression(else_branch, &mut else_owned)?;
60:                 // Linear types requirement: both branches must leave the same set of owned variables
61:                 if then_owned != else_owned {
62:                     return Err(OnuError::OwnershipViolation {
63:                         message: "Branches of 'if' must result in the same ownership state".to_string(),
64:                         span: crate::domain::entities::error::Span::default()
65:                     });
66:                 }
67:                 *owned_vars = then_owned;
68:             }
69:             HirExpression::Block(exprs) => {
70:                 for expr in exprs {
71:                     self.check_expression(expr, owned_vars)?;
72:                 }
73:             }
74:             HirExpression::Emit(e) => {
75:                 self.check_expression(e, owned_vars)?;
76:             }
77:             HirExpression::Tuple(exprs) => {
78:                 for expr in exprs {
79:                     self.check_expression(expr, owned_vars)?;
80:                 }
81:             }
82:             _ => {}
83:         }
84:         Ok(())
85:     }
86: }
</file>

<file path="src/domain/mod.rs">
1: pub mod entities; pub mod rules;
</file>

<file path="src/infrastructure/cli/mod.rs">
1: pub mod parser;
2: pub use parser::CliParser;
</file>

<file path="src/infrastructure/cli/parser.rs">
 1: use crate::application::options::{CompilationOptions, CompilerStage, LogLevel};
 2: use crate::domain::entities::error::{OnuError, Span};
 3: pub struct CliParser;
 4: impl CliParser {
 5:     pub fn parse_args(args: &[String]) -> Result<(String, CompilationOptions), OnuError> {
 6:         if args.len() < 2 {
 7:             return Err(OnuError::GrammarViolation {
 8:                 message: "Usage: onu <source_file> [options]".to_string(),
 9:                 span: Span::default()
10:             });
11:         }
12:         let source_file = args[1].clone();
13:         let mut options = CompilationOptions::default();
14:         let mut i = 2;
15:         while i < args.len() {
16:             match args[i].as_str() {
17:                 "--verbose" | "-v" => options.log_level = LogLevel::Debug,
18:                 "--stop-after" => {
19:                     if i + 1 < args.len() {
20:                         options.stop_after = CompilerStage::from_str(&args[i+1]);
21:                         i += 1;
22:                     }
23:                 }
24:                 "--emit-hir" => options.emit_hir = true,
25:                 "--emit-mir" => options.emit_mir = true,
26:                 "--emit-tokens" => options.emit_tokens = true,
27:                 _ => {}
28:             }
29:             i += 1;
30:         }
31:         Ok((source_file, options))
32:     }
33: }
</file>

<file path="src/infrastructure/extensions/io.rs">
 1: use crate::application::ports::compiler_ports::ExtensionPort;
 2: use crate::domain::entities::registry::{BuiltInModule, SymbolTable, BehaviorSignature};
 3: use crate::domain::entities::types::OnuType;
 4: pub struct OnuIoModule;
 5: impl BuiltInModule for OnuIoModule {
 6:     fn name(&self) -> &str { "Ọ̀nụ-IO" }
 7:     fn register(&self, table: &mut SymbolTable) {
 8:         let io_verbs = vec![
 9:             ("broadcasts", BehaviorSignature {
10:                 input_types: vec![OnuType::Strings],
11:                 return_type: OnuType::Nothing,
12:                 arg_is_observation: vec![true]
13:             }),
14:             ("receives-argument", BehaviorSignature {
15:                 input_types: vec![OnuType::I64],
16:                 return_type: OnuType::Strings,
17:                 arg_is_observation: vec![false]
18:             }),
19:             ("argument-count", BehaviorSignature {
20:                 input_types: vec![],
21:                 return_type: OnuType::I64,
22:                 arg_is_observation: vec![]
23:             }),
24:             ("receives-line", BehaviorSignature {
25:                 input_types: vec![],
26:                 return_type: OnuType::Strings,
27:                 arg_is_observation: vec![]
28:             }),
29:         ];
30:         for (name, sig) in io_verbs {
31:             table.add_signature(name, sig);
32:             table.mark_implemented(name);
33:         }
34:     }
35: }
36: impl ExtensionPort for OnuIoModule {
37:     fn realization_id(&self) -> &str { "io" }
38: }
</file>

<file path="src/infrastructure/extensions/mod.rs">
1: pub mod io;
</file>

<file path="src/infrastructure/os/mod.rs">
 1: use crate::application::ports::environment::EnvironmentPort;
 2: use crate::application::options::LogLevel;
 3: use crate::domain::entities::error::OnuError;
 4: use std::fs;
 5: use std::process::Command;
 6: use chrono::Local;
 7: pub struct NativeOsEnvironment {
 8:     pub current_log_level: LogLevel,
 9: }
10: impl NativeOsEnvironment {
11:     pub fn new(log_level: LogLevel) -> Self {
12:         Self { current_log_level: log_level }
13:     }
14: }
15: impl EnvironmentPort for NativeOsEnvironment {
16:     fn read_file(&self, path: &str) -> Result<String, OnuError> {
17:         self.log(LogLevel::Debug, &format!("Reading file: {}", path));
18:         fs::read_to_string(path).map_err(|e| OnuError::ResourceViolation {
19:             message: format!("Failed to read {}: {}", path, e),
20:             span: crate::domain::entities::error::Span::default(),
21:         })
22:     }
23:     fn write_file(&self, path: &str, content: &str) -> Result<(), OnuError> {
24:         self.log(LogLevel::Debug, &format!("Writing file: {}", path));
25:         fs::write(path, content).map_err(|e| OnuError::ResourceViolation {
26:             message: format!("Failed to write {}: {}", path, e),
27:             span: crate::domain::entities::error::Span::default(),
28:         })
29:     }
30:     fn write_binary(&self, path: &str, content: &[u8]) -> Result<(), OnuError> {
31:         self.log(LogLevel::Debug, &format!("Writing binary: {}", path));
32:         fs::write(path, content).map_err(|e| OnuError::ResourceViolation {
33:             message: format!("Failed to write binary {}: {}", path, e),
34:             span: crate::domain::entities::error::Span::default(),
35:         })
36:     }
37:     fn run_command(&self, command: &str, args: &[&str]) -> Result<String, OnuError> {
38:         self.log(LogLevel::Info, &format!("Executing command: {} {:?}", command, args));
39:         let output = Command::new(command)
40:             .args(args)
41:             .output()
42:             .map_err(|e| OnuError::ResourceViolation {
43:                 message: format!("Failed to execute {}: {}", command, e),
44:                 span: crate::domain::entities::error::Span::default(),
45:             })?;
46:         if output.status.success() {
47:             Ok(String::from_utf8_lossy(&output.stdout).to_string())
48:         } else {
49:             Err(OnuError::ResourceViolation {
50:                 message: format!("Command [{}] failed. Error: {}", command, String::from_utf8_lossy(&output.stderr)),
51:                 span: crate::domain::entities::error::Span::default(),
52:             })
53:         }
54:     }
55:     fn log(&self, level: LogLevel, message: &str) {
56:         if level <= self.current_log_level && level != LogLevel::None {
57:             let timestamp = Local::now().to_rfc3339();
58:             eprintln!("[{}] {:?}: {}", timestamp, level, message);
59:         }
60:     }
61: }
</file>

<file path="src/main.rs">
 1: use onu_refactor::application::options::{CompilationOptions, CompilerStage, LogLevel};
 2: use onu_refactor::infrastructure::os::NativeOsEnvironment;
 3: use onu_refactor::adapters::codegen::OnuCodegen;
 4: use onu_refactor::CompilationPipeline;
 5: use std::env as std_env;
 6: fn main() {
 7:     let args: Vec<String> = std_env::args().collect();
 8:     if args.len() < 2 {
 9:         eprintln!("Usage: {} <source_file> [--stop-after <stage>] [--verbose]", args[0]);
10:         std::process::exit(1);
11:     }
12:     let source_file = &args[1];
13:     let mut options = CompilationOptions::default();
14:     let mut i = 2;
15:     while i < args.len() {
16:         if args[i] == "--stop-after" && i + 1 < args.len() {
17:             options.stop_after = CompilerStage::from_str(&args[i+1]);
18:             i += 1;
19:         } else if args[i] == "--verbose" {
20:             options.log_level = LogLevel::Debug;
21:         }
22:         i += 1;
23:     }
24:     let env = NativeOsEnvironment::new(options.log_level);
25:     let codegen = OnuCodegen::new(options.log_level);
26:     let mut pipeline = CompilationPipeline::new(env, codegen, options);
27:     match pipeline.compile(source_file) {
28:         Ok(_) => println!("Discourse Realized Successfully."),
29:         Err(e) => {
30:             eprintln!("PIPELINE ERROR: {:?}", e);
31:             std::process::exit(1);
32:         }
33:     }
34: }
</file>

<file path="tests/module_test.rs">
 1: use onu_refactor::CompilationPipeline;
 2: use onu_refactor::infrastructure::os::NativeOsEnvironment;
 3: use onu_refactor::adapters::codegen::OnuCodegen;
 4: use onu_refactor::application::options::CompilationOptions;
 5: #[test]
 6: fn test_module_registration() {
 7:     let env = NativeOsEnvironment;
 8:     let codegen = OnuCodegen::new();
 9:     let options = CompilationOptions::default();
10:     let pipeline = CompilationPipeline::new(env, codegen, options);
11:     assert!(pipeline.registry.get_signature("len").is_some());
12:     assert!(pipeline.registry.get_signature("added-to").is_some());
13:     assert!(pipeline.registry.get_signature("broadcasts").is_some());
14: }
</file>

<file path="tests/pipeline_test.rs">
 1: use onu_refactor::application::use_cases::lowering_service::LoweringService;
 2: use onu_refactor::domain::entities::ast::{Discourse, BehaviorHeader, Expression, ReturnType};
 3: use onu_refactor::domain::entities::hir::{HirDiscourse, HirExpression, HirLiteral};
 4: use onu_refactor::domain::entities::types::OnuType;
 5: #[test]
 6: fn test_synthetic_argument_injection() {
 7:     let header = BehaviorHeader {
 8:         name: "main".to_string(),
 9:         is_effect: true,
10:         intent: "Test".to_string(),
11:         takes: vec![],
12:         delivers: ReturnType(OnuType::Nothing),
13:         diminishing: None,
14:         skip_termination_check: false,
15:     };
16:     let body = Expression::Nothing;
17:     let discourse = Discourse::Behavior { header, body };
18:     let registry = onu_refactor::application::use_cases::registry_service::RegistryService::new();
19:     let hir = LoweringService::lower_discourse(&discourse, &registry);
20:     if let HirDiscourse::Behavior { header, .. } = hir {
21:         assert_eq!(header.args.len(), 2);
22:         assert_eq!(header.args[0].name, "__argc");
23:         assert_eq!(header.args[1].name, "__argv");
24:     } else {
25:         panic!("Expected Behavior");
26:     }
27: }
28: #[test]
29: fn test_broadcasts_lowering() {
30:     let header = BehaviorHeader {
31:         name: "test".to_string(),
32:         is_effect: true,
33:         intent: "Test".to_string(),
34:         takes: vec![],
35:         delivers: ReturnType(OnuType::Nothing),
36:         diminishing: None,
37:         skip_termination_check: false,
38:     };
39:     let body = Expression::Emit(Box::new(Expression::Text("Hello".to_string())));
40:     let discourse = Discourse::Behavior { header, body };
41:     let registry = onu_refactor::application::use_cases::registry_service::RegistryService::new();
42:     let hir = LoweringService::lower_discourse(&discourse, &registry);
43:     if let HirDiscourse::Behavior { body, .. } = hir {
44:         match body {
45:             HirExpression::Emit(inner) => {
46:                 if let HirExpression::Literal(HirLiteral::Text(s)) = *inner {
47:                     assert_eq!(s, "Hello");
48:                 } else {
49:                     panic!("Expected Text literal in Emit");
50:                 }
51:             }
52:             _ => panic!("Expected Emit expression in HIR"),
53:         }
54:     } else {
55:         panic!("Expected Behavior");
56:     }
57: }
58: #[test]
59: fn test_drop_lowering() {
60:     let header = BehaviorHeader {
61:         name: "test".to_string(),
62:         is_effect: true,
63:         intent: "Test".to_string(),
64:         takes: vec![],
65:         delivers: ReturnType(OnuType::Nothing),
66:         diminishing: None,
67:         skip_termination_check: false,
68:     };
69:     let body = Expression::Drop(Box::new(Expression::Identifier("x".to_string())));
70:     let discourse = Discourse::Behavior { header, body };
71:     let registry = onu_refactor::application::use_cases::registry_service::RegistryService::new();
72:     let hir = LoweringService::lower_discourse(&discourse, &registry);
73:     if let HirDiscourse::Behavior { body, .. } = hir {
74:         match body {
75:             HirExpression::Drop(inner) => {
76:                 if let HirExpression::Variable(name, _) = *inner {
77:                     assert_eq!(name, "x");
78:                 } else {
79:                     panic!("Expected Variable in Drop");
80:                 }
81:             }
82:             _ => panic!("Expected Drop expression in HIR"),
83:         }
84:     } else {
85:         panic!("Expected Behavior");
86:     }
87: }
</file>

<file path="src/application/ports/compiler_ports.rs">
 1: use crate::domain::entities::error::OnuError;
 2: use crate::domain::entities::ast::Discourse;
 3: use crate::domain::entities::mir::MirProgram;
 4: #[derive(Debug, Clone, PartialEq, Eq, Hash)]
 5: pub enum Token {
 6:     Identifier(String),
 7:     Literal(Literal),
 8:     Operator(String),
 9:     Delimiter(char),
10:     Indent,
11:     Dedent,
12:     LineStart(usize),
13:     TheModuleCalled,
14:     TheBehaviorCalled,
15:     TheEffectBehaviorCalled,
16:     WithConcern,
17:     WithIntent,
18:     WithDiminishing,
19:     NoGuaranteedTermination,
20:     DerivesFrom,
21:     DecreasedBy,
22:     PartitionsBy,
23:     ScalesBy,
24:     AddedTo,
25:     Utilizes,
26:     As,
27:     Takes,
28:     Delivers,
29:     Called,
30:     If,
31:     Then,
32:     Else,
33:     Derivation,
34:     Broadcasts,
35:     Nothing,
36:     Matches,
37:     Exceeds,
38:     FallsShortOf,
39:     UnitesWith,
40:     JoinsWith,
41:     Opposes,
42:     InitOf,
43:     TailOf,
44: }
45: #[derive(Debug, Clone, PartialEq, Eq, Hash)]
46: pub enum Literal {
47:     Integer(i128),
48:     FloatBits(u64),
49:     String(String),
50:     Boolean(bool),
51: }
52: pub trait LexerPort {
53:     fn lex(&self, source: &str) -> Result<Vec<Token>, OnuError>;
54: }
55: pub trait ParserPort {
56:     fn parse(&self, tokens: Vec<Token>) -> Result<Vec<Discourse>, OnuError>;
57: }
58: pub trait CodegenPort {
59:     fn generate(&self, program: &MirProgram) -> Result<String, OnuError>;
60:     fn set_registry(&mut self, registry: crate::application::use_cases::registry_service::RegistryService);
61: }
62: pub trait ExtensionPort: crate::domain::entities::registry::BuiltInModule {
63:     fn realization_id(&self) -> &str;
64: }
</file>

<file path="src/application/use_cases/mod.rs">
1: pub mod registry_service;
2: pub mod analysis_service;
3: pub mod lowering_service;
4: pub mod mir_lowering_service;
5: pub mod mir_builder;
6: pub mod layout_service;
7: pub mod module_service;
</file>

<file path="src/application/use_cases/registry_service.rs">
 1: use crate::domain::entities::registry::{SymbolTable, BehaviorSignature};
 2: use crate::application::options::LogLevel;
 3: use std::collections::HashMap;
 4: use chrono::Local;
 5: pub struct RegistryService {
 6:     symbols: SymbolTable,
 7:     shapes: HashMap<String, Vec<(String, BehaviorSignature)>>,
 8:     pub log_level: LogLevel,
 9: }
10: impl RegistryService {
11:     pub fn new() -> Self {
12:         Self {
13:             symbols: SymbolTable::new(),
14:             shapes: HashMap::new(),
15:             log_level: LogLevel::Info,
16:         }
17:     }
18:     fn log(&self, level: LogLevel, message: &str) {
19:         if level <= self.log_level && level != LogLevel::None {
20:             let timestamp = Local::now().to_rfc3339();
21:             eprintln!("[{}] {:?}: [Registry] {}", timestamp, level, message);
22:         }
23:     }
24:     pub fn get_signature(&self, name: &str) -> Option<&BehaviorSignature> {
25:         self.log(LogLevel::Trace, &format!("Looking up signature for: {}", name));
26:         self.symbols.get_signature(name)
27:     }
28:     pub fn add_shape(&mut self, name: &str, behaviors: Vec<(String, BehaviorSignature)>) {
29:         self.log(LogLevel::Debug, &format!("Adding shape: {}", name));
30:         self.shapes.insert(name.to_string(), behaviors);
31:     }
32:     pub fn symbols_mut(&mut self) -> &mut SymbolTable {
33:         &mut self.symbols
34:     }
35:     pub fn mark_implemented(&mut self, name: &str) {
36:         self.log(LogLevel::Trace, &format!("Marking implemented: {}", name));
37:         self.symbols.mark_implemented(name);
38:     }
39: }
40: impl Clone for RegistryService {
41:     fn clone(&self) -> Self {
42:         Self {
43:             symbols: self.symbols.clone(),
44:             shapes: self.shapes.clone(),
45:             log_level: self.log_level,
46:         }
47:     }
48: }
</file>

<file path="src/domain/entities/mod.rs">
1: pub mod types; pub mod error; pub mod registry; pub mod ast; pub mod hir; pub mod mir; pub mod core_module;
</file>

<file path="src/domain/entities/registry.rs">
 1: use crate::domain::entities::types::OnuType;
 2: use std::collections::{HashMap, HashSet};
 3: #[derive(Debug, Clone, PartialEq, Eq, Hash)]
 4: pub struct BehaviorSignature {
 5:     pub input_types: Vec<OnuType>,
 6:     pub return_type: OnuType,
 7:     pub arg_is_observation: Vec<bool>,
 8: }
 9: #[derive(Debug, Clone, Default)]
10: pub struct SymbolTable {
11:     names: HashSet<String>,
12:     implemented_names: HashSet<String>,
13:     arities: HashMap<String, usize>,
14:     signatures: HashMap<String, BehaviorSignature>,
15: }
16: impl SymbolTable {
17:     pub fn new() -> Self {
18:         Self::default()
19:     }
20:     pub fn contains(&self, name: &str) -> bool {
21:         self.names.contains(name)
22:     }
23:     pub fn is_implemented(&self, name: &str) -> bool {
24:         self.implemented_names.contains(name)
25:     }
26:     pub fn mark_implemented(&mut self, name: &str) {
27:         self.implemented_names.insert(name.to_string());
28:     }
29:     pub fn add_name(&mut self, name: &str, arity: usize) {
30:         self.names.insert(name.to_string());
31:         self.arities.insert(name.to_string(), arity);
32:     }
33:     pub fn add_signature(&mut self, name: &str, signature: BehaviorSignature) {
34:         self.names.insert(name.to_string());
35:         self.arities.insert(name.to_string(), signature.input_types.len());
36:         self.signatures.insert(name.to_string(), signature);
37:     }
38:     pub fn get_signature(&self, name: &str) -> Option<&BehaviorSignature> {
39:         self.signatures.get(name)
40:     }
41:     pub fn get_arity(&self, name: &str) -> Option<usize> {
42:         self.arities.get(name).copied()
43:     }
44: }
45: pub trait BuiltInModule {
46:     fn name(&self) -> &str;
47:     fn register(&self, table: &mut SymbolTable);
48: }
49: pub trait Extension: BuiltInModule {
50:     fn realization_id(&self) -> &str;
51: }
</file>

<file path="src/infrastructure/mod.rs">
1: pub mod os;
2: pub mod cli;
3: pub mod extensions;
</file>

<file path="src/lib.rs">
 1: pub mod domain;
 2: pub mod application;
 3: pub mod infrastructure;
 4: pub mod adapters;
 5: use crate::application::use_cases::registry_service::RegistryService;
 6: use crate::application::use_cases::analysis_service::AnalysisService;
 7: use crate::application::use_cases::lowering_service::LoweringService;
 8: use crate::application::use_cases::mir_lowering_service::MirLoweringService;
 9: use crate::application::use_cases::layout_service::LayoutService;
10: use crate::application::use_cases::module_service::ModuleService;
11: use crate::application::ports::compiler_ports::{LexerPort, ParserPort, CodegenPort};
12: use crate::application::ports::environment::EnvironmentPort;
13: use crate::application::options::{CompilationOptions, CompilerStage, LogLevel};
14: use crate::domain::entities::error::OnuError;
15: use crate::domain::entities::ast::Discourse;
16: use crate::domain::entities::core_module::{CoreModule, StandardMathModule};
17: use crate::infrastructure::extensions::io::OnuIoModule;
18: use crate::adapters::lexer::OnuLexer;
19: use crate::adapters::parser::OnuParser;
20: pub struct CompilationPipeline<E: EnvironmentPort, C: CodegenPort> {
21:     pub env: E,
22:     pub codegen: C,
23:     pub options: CompilationOptions,
24:     pub registry: RegistryService,
25:     pub lexer: OnuLexer,
26:     pub parser: OnuParser,
27:     pub module_service: ModuleService,
28: }
29: impl<E: EnvironmentPort, C: CodegenPort> CompilationPipeline<E, C> {
30:     pub fn new(env: E, codegen: C, options: CompilationOptions) -> Self {
31:         let mut registry = RegistryService::new();
32:         registry.log_level = options.log_level;
33:         let module_service = ModuleService::new(options.log_level);
34:         module_service.register_module(&mut registry, &CoreModule);
35:         module_service.register_module(&mut registry, &StandardMathModule);
36:         module_service.register_module(&mut registry, &OnuIoModule);
37:         Self {
38:             env,
39:             codegen,
40:             options: options.clone(),
41:             registry,
42:             lexer: OnuLexer::new(options.log_level),
43:             parser: OnuParser::new(options.log_level),
44:             module_service,
45:         }
46:     }
47:     pub fn compile(&mut self, path: &str) -> Result<(), OnuError> {
48:         self.env.log(LogLevel::Info, &format!("Starting compilation for: {}", path));
49:         let source = self.env.read_file(path)?;
50:         let raw_tokens = self.lexer.lex(&source)?;
51:         let mut layout_service = LayoutService::new(self.options.log_level);
52:         let tokens = layout_service.process(&source, raw_tokens);
53:         if self.options.stop_after == Some(CompilerStage::Lexing) { return Ok(()); }
54:         let discourses = self.parser.parse(tokens)?;
55:         for discourse in &discourses {
56:             if let Discourse::Behavior { header, .. } = discourse {
57:                 let sig = crate::domain::entities::registry::BehaviorSignature {
58:                     input_types: header.takes.iter().map(|a| a.type_info.onu_type.clone()).collect(),
59:                     return_type: header.delivers.0.clone(),
60:                     arg_is_observation: header.takes.iter().map(|a| a.type_info.is_observation).collect(),
61:                 };
62:                 self.registry.symbols_mut().add_signature(&header.name, sig);
63:             }
64:         }
65:         if self.options.stop_after == Some(CompilerStage::Parsing) { return Ok(()); }
66:         let analysis_service = AnalysisService::new(&self.registry);
67:         let mut hir_discourses = Vec::new();
68:         for discourse in discourses {
69:             let mut hir = LoweringService::lower_discourse(&discourse, &self.registry);
70:             analysis_service.analyze_discourse(&mut hir)?;
71:             if self.options.emit_hir { self.env.log(LogLevel::Debug, &format!("HIR Emit: {:?}", hir)); }
72:             hir_discourses.push(hir);
73:         }
74:         if self.options.stop_after == Some(CompilerStage::Analysis) { return Ok(()); }
75:         let mir_lowering_service = MirLoweringService::new(&self.env);
76:         let mir = mir_lowering_service.lower_program(&hir_discourses)?;
77:         if self.options.stop_after == Some(CompilerStage::Mir) { return Ok(()); }
78:         self.env.log(LogLevel::Info, "Starting Codegen stage.");
79:         self.codegen.set_registry(self.registry.clone());
80:         let ir = self.codegen.generate(&mir)?;
81:         self.env.log(LogLevel::Debug, &format!("Generated LLVM IR:\n{}", ir));
82:         let stem = std::path::Path::new(path).file_stem().unwrap().to_str().unwrap();
83:         let ll_path = format!("{}.ll", stem);
84:         let prog_path = format!("{}_bin", stem);
85:         self.env.write_file(&ll_path, &ir)?;
86:         if self.options.stop_after == Some(CompilerStage::Codegen) { return Ok(()); }
87:         self.realize(&ll_path, &prog_path)?;
88:         Ok(())
89:     }
90:     fn realize(&self, bitcode_path: &str, output_path: &str) -> Result<(), OnuError> {
91:         self.env.log(LogLevel::Info, &format!("Realizing binary: {} -> {}", bitcode_path, output_path));
92:         self.env.run_command("clang", &[bitcode_path, "runtime.c", "-o", output_path, "-Wno-override-module"])?;
93:         Ok(())
94:     }
95: }
</file>

</files>
