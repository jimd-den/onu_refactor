the module called CollatzBenchmark
    with concern: recursive performance verification

the behavior called collatz-steps
    with intent: count steps to reach 1
    takes:
        an integer called n
        an integer called count
    delivers: an integer
    with no guaranteed termination
    as:
        if n matches 1
            then count
            else
                derivation: half    derives-from n partitions-by 2
                derivation: is-even derives-from (half scales-by 2) matches n
                derivation: next    derives-from if is-even then half else (n scales-by 3 added-to 1)
                derivation: next-count derives-from count added-to 1
                next utilizes collatz-steps next-count

the behavior called collatz-range
    with intent: sum steps for a range of numbers
    takes:
        an integer called current
        an integer called target
        an integer called accumulator
    delivers: an integer
    with no guaranteed termination
    as:
        if current exceeds target
            then accumulator
            else
                derivation: steps derives-from current utilizes collatz-steps 0
                derivation: next  derives-from current added-to 1
                next utilizes collatz-range target (accumulator added-to steps)

the effect behavior called run
    takes: nothing
    delivers: an integer
    as:
        derivation: limit  derives-from 1000000
        derivation: result derives-from 1 utilizes collatz-range limit 0
        
        derivation: msg derives-from "Total Collatz steps for 1 to " joined-with (limit utilizes as-text)
        derivation: msg2 derives-from msg joined-with " is: "
        derivation: msg3 derives-from msg2 joined-with (result utilizes as-text)
        broadcasts msg3
        
        0
